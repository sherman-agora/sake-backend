// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  expiryDateSummary: (where?: ExpiryDateSummaryWhereInput) => Promise<boolean>;
  inventoryItem: (where?: InventoryItemWhereInput) => Promise<boolean>;
  productSummary: (where?: ProductSummaryWhereInput) => Promise<boolean>;
  warehouse: (where?: WarehouseWhereInput) => Promise<boolean>;
  warehouseSummary: (where?: WarehouseSummaryWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  expiryDateSummary: (
    where: ExpiryDateSummaryWhereUniqueInput
  ) => ExpiryDateSummaryNullablePromise;
  expiryDateSummaries: (args?: {
    where?: ExpiryDateSummaryWhereInput;
    orderBy?: ExpiryDateSummaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExpiryDateSummary>;
  expiryDateSummariesConnection: (args?: {
    where?: ExpiryDateSummaryWhereInput;
    orderBy?: ExpiryDateSummaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpiryDateSummaryConnectionPromise;
  inventoryItem: (
    where: InventoryItemWhereUniqueInput
  ) => InventoryItemNullablePromise;
  inventoryItems: (args?: {
    where?: InventoryItemWhereInput;
    orderBy?: InventoryItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<InventoryItem>;
  inventoryItemsConnection: (args?: {
    where?: InventoryItemWhereInput;
    orderBy?: InventoryItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InventoryItemConnectionPromise;
  productSummary: (
    where: ProductSummaryWhereUniqueInput
  ) => ProductSummaryNullablePromise;
  productSummaries: (args?: {
    where?: ProductSummaryWhereInput;
    orderBy?: ProductSummaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductSummary>;
  productSummariesConnection: (args?: {
    where?: ProductSummaryWhereInput;
    orderBy?: ProductSummaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductSummaryConnectionPromise;
  warehouse: (where: WarehouseWhereUniqueInput) => WarehouseNullablePromise;
  warehouses: (args?: {
    where?: WarehouseWhereInput;
    orderBy?: WarehouseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Warehouse>;
  warehousesConnection: (args?: {
    where?: WarehouseWhereInput;
    orderBy?: WarehouseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WarehouseConnectionPromise;
  warehouseSummary: (
    where: WarehouseSummaryWhereUniqueInput
  ) => WarehouseSummaryNullablePromise;
  warehouseSummaries: (args?: {
    where?: WarehouseSummaryWhereInput;
    orderBy?: WarehouseSummaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WarehouseSummary>;
  warehouseSummariesConnection: (args?: {
    where?: WarehouseSummaryWhereInput;
    orderBy?: WarehouseSummaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WarehouseSummaryConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createExpiryDateSummary: (
    data: ExpiryDateSummaryCreateInput
  ) => ExpiryDateSummaryPromise;
  updateExpiryDateSummary: (args: {
    data: ExpiryDateSummaryUpdateInput;
    where: ExpiryDateSummaryWhereUniqueInput;
  }) => ExpiryDateSummaryPromise;
  updateManyExpiryDateSummaries: (args: {
    data: ExpiryDateSummaryUpdateManyMutationInput;
    where?: ExpiryDateSummaryWhereInput;
  }) => BatchPayloadPromise;
  upsertExpiryDateSummary: (args: {
    where: ExpiryDateSummaryWhereUniqueInput;
    create: ExpiryDateSummaryCreateInput;
    update: ExpiryDateSummaryUpdateInput;
  }) => ExpiryDateSummaryPromise;
  deleteExpiryDateSummary: (
    where: ExpiryDateSummaryWhereUniqueInput
  ) => ExpiryDateSummaryPromise;
  deleteManyExpiryDateSummaries: (
    where?: ExpiryDateSummaryWhereInput
  ) => BatchPayloadPromise;
  createInventoryItem: (data: InventoryItemCreateInput) => InventoryItemPromise;
  updateInventoryItem: (args: {
    data: InventoryItemUpdateInput;
    where: InventoryItemWhereUniqueInput;
  }) => InventoryItemPromise;
  updateManyInventoryItems: (args: {
    data: InventoryItemUpdateManyMutationInput;
    where?: InventoryItemWhereInput;
  }) => BatchPayloadPromise;
  upsertInventoryItem: (args: {
    where: InventoryItemWhereUniqueInput;
    create: InventoryItemCreateInput;
    update: InventoryItemUpdateInput;
  }) => InventoryItemPromise;
  deleteInventoryItem: (
    where: InventoryItemWhereUniqueInput
  ) => InventoryItemPromise;
  deleteManyInventoryItems: (
    where?: InventoryItemWhereInput
  ) => BatchPayloadPromise;
  createProductSummary: (
    data: ProductSummaryCreateInput
  ) => ProductSummaryPromise;
  updateProductSummary: (args: {
    data: ProductSummaryUpdateInput;
    where: ProductSummaryWhereUniqueInput;
  }) => ProductSummaryPromise;
  updateManyProductSummaries: (args: {
    data: ProductSummaryUpdateManyMutationInput;
    where?: ProductSummaryWhereInput;
  }) => BatchPayloadPromise;
  upsertProductSummary: (args: {
    where: ProductSummaryWhereUniqueInput;
    create: ProductSummaryCreateInput;
    update: ProductSummaryUpdateInput;
  }) => ProductSummaryPromise;
  deleteProductSummary: (
    where: ProductSummaryWhereUniqueInput
  ) => ProductSummaryPromise;
  deleteManyProductSummaries: (
    where?: ProductSummaryWhereInput
  ) => BatchPayloadPromise;
  createWarehouse: (data: WarehouseCreateInput) => WarehousePromise;
  updateWarehouse: (args: {
    data: WarehouseUpdateInput;
    where: WarehouseWhereUniqueInput;
  }) => WarehousePromise;
  updateManyWarehouses: (args: {
    data: WarehouseUpdateManyMutationInput;
    where?: WarehouseWhereInput;
  }) => BatchPayloadPromise;
  upsertWarehouse: (args: {
    where: WarehouseWhereUniqueInput;
    create: WarehouseCreateInput;
    update: WarehouseUpdateInput;
  }) => WarehousePromise;
  deleteWarehouse: (where: WarehouseWhereUniqueInput) => WarehousePromise;
  deleteManyWarehouses: (where?: WarehouseWhereInput) => BatchPayloadPromise;
  createWarehouseSummary: (
    data: WarehouseSummaryCreateInput
  ) => WarehouseSummaryPromise;
  updateWarehouseSummary: (args: {
    data: WarehouseSummaryUpdateInput;
    where: WarehouseSummaryWhereUniqueInput;
  }) => WarehouseSummaryPromise;
  updateManyWarehouseSummaries: (args: {
    data: WarehouseSummaryUpdateManyMutationInput;
    where?: WarehouseSummaryWhereInput;
  }) => BatchPayloadPromise;
  upsertWarehouseSummary: (args: {
    where: WarehouseSummaryWhereUniqueInput;
    create: WarehouseSummaryCreateInput;
    update: WarehouseSummaryUpdateInput;
  }) => WarehouseSummaryPromise;
  deleteWarehouseSummary: (
    where: WarehouseSummaryWhereUniqueInput
  ) => WarehouseSummaryPromise;
  deleteManyWarehouseSummaries: (
    where?: WarehouseSummaryWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  expiryDateSummary: (
    where?: ExpiryDateSummarySubscriptionWhereInput
  ) => ExpiryDateSummarySubscriptionPayloadSubscription;
  inventoryItem: (
    where?: InventoryItemSubscriptionWhereInput
  ) => InventoryItemSubscriptionPayloadSubscription;
  productSummary: (
    where?: ProductSummarySubscriptionWhereInput
  ) => ProductSummarySubscriptionPayloadSubscription;
  warehouse: (
    where?: WarehouseSubscriptionWhereInput
  ) => WarehouseSubscriptionPayloadSubscription;
  warehouseSummary: (
    where?: WarehouseSummarySubscriptionWhereInput
  ) => WarehouseSummarySubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type WarehouseType =
  | "PENDING"
  | "NORMAL"
  | "DISPOSE"
  | "TEMPORARY"
  | "MARKETING"
  | "OUT"
  | "OUTGOING";

export type InventoryItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "productId_ASC"
  | "productId_DESC"
  | "purchaseOrderId_ASC"
  | "purchaseOrderId_DESC"
  | "deliveryNoteId_ASC"
  | "deliveryNoteId_DESC"
  | "label_ASC"
  | "label_DESC"
  | "expiryDate_ASC"
  | "expiryDate_DESC"
  | "cost_ASC"
  | "cost_DESC";

export type ExpiryDateSummaryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "productId_ASC"
  | "productId_DESC"
  | "expiryDate_ASC"
  | "expiryDate_DESC"
  | "quantity_ASC"
  | "quantity_DESC";

export type WarehouseSummaryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "productId_ASC"
  | "productId_DESC"
  | "quantity_ASC"
  | "quantity_DESC";

export type ProductSummaryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "productId_ASC"
  | "productId_DESC"
  | "incomingQuantity_ASC"
  | "incomingQuantity_DESC"
  | "outgoingQuantity_ASC"
  | "outgoingQuantity_DESC"
  | "quantity_ASC"
  | "quantity_DESC";

export type WarehouseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "address_ASC"
  | "address_DESC"
  | "type_ASC"
  | "type_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface WarehouseSummaryCreateManyWithoutWarehouseInput {
  create?: Maybe<
    | WarehouseSummaryCreateWithoutWarehouseInput[]
    | WarehouseSummaryCreateWithoutWarehouseInput
  >;
  connect?: Maybe<
    WarehouseSummaryWhereUniqueInput[] | WarehouseSummaryWhereUniqueInput
  >;
}

export type ExpiryDateSummaryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput {
  where: InventoryItemWhereUniqueInput;
  data: InventoryItemUpdateWithoutWarehouseDataInput;
}

export interface ProductSummaryCreateInput {
  id?: Maybe<ID_Input>;
  productId: ID_Input;
  incomingQuantity: Int;
  outgoingQuantity: Int;
  quantity: Int;
}

export type WarehouseSummaryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WarehouseSummaryUpdateManyWithoutWarehouseInput {
  create?: Maybe<
    | WarehouseSummaryCreateWithoutWarehouseInput[]
    | WarehouseSummaryCreateWithoutWarehouseInput
  >;
  delete?: Maybe<
    WarehouseSummaryWhereUniqueInput[] | WarehouseSummaryWhereUniqueInput
  >;
  connect?: Maybe<
    WarehouseSummaryWhereUniqueInput[] | WarehouseSummaryWhereUniqueInput
  >;
  set?: Maybe<
    WarehouseSummaryWhereUniqueInput[] | WarehouseSummaryWhereUniqueInput
  >;
  disconnect?: Maybe<
    WarehouseSummaryWhereUniqueInput[] | WarehouseSummaryWhereUniqueInput
  >;
  update?: Maybe<
    | WarehouseSummaryUpdateWithWhereUniqueWithoutWarehouseInput[]
    | WarehouseSummaryUpdateWithWhereUniqueWithoutWarehouseInput
  >;
  upsert?: Maybe<
    | WarehouseSummaryUpsertWithWhereUniqueWithoutWarehouseInput[]
    | WarehouseSummaryUpsertWithWhereUniqueWithoutWarehouseInput
  >;
  deleteMany?: Maybe<
    WarehouseSummaryScalarWhereInput[] | WarehouseSummaryScalarWhereInput
  >;
  updateMany?: Maybe<
    | WarehouseSummaryUpdateManyWithWhereNestedInput[]
    | WarehouseSummaryUpdateManyWithWhereNestedInput
  >;
}

export interface InventoryItemUpdateManyWithoutWarehouseInput {
  create?: Maybe<
    | InventoryItemCreateWithoutWarehouseInput[]
    | InventoryItemCreateWithoutWarehouseInput
  >;
  delete?: Maybe<
    InventoryItemWhereUniqueInput[] | InventoryItemWhereUniqueInput
  >;
  connect?: Maybe<
    InventoryItemWhereUniqueInput[] | InventoryItemWhereUniqueInput
  >;
  set?: Maybe<InventoryItemWhereUniqueInput[] | InventoryItemWhereUniqueInput>;
  disconnect?: Maybe<
    InventoryItemWhereUniqueInput[] | InventoryItemWhereUniqueInput
  >;
  update?: Maybe<
    | InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput[]
    | InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput
  >;
  upsert?: Maybe<
    | InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput[]
    | InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput
  >;
  deleteMany?: Maybe<
    InventoryItemScalarWhereInput[] | InventoryItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | InventoryItemUpdateManyWithWhereNestedInput[]
    | InventoryItemUpdateManyWithWhereNestedInput
  >;
}

export interface WarehouseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WarehouseWhereInput>;
  AND?: Maybe<
    WarehouseSubscriptionWhereInput[] | WarehouseSubscriptionWhereInput
  >;
  OR?: Maybe<
    WarehouseSubscriptionWhereInput[] | WarehouseSubscriptionWhereInput
  >;
  NOT?: Maybe<
    WarehouseSubscriptionWhereInput[] | WarehouseSubscriptionWhereInput
  >;
}

export interface WarehouseUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  type?: Maybe<WarehouseType>;
  products?: Maybe<InventoryItemUpdateManyWithoutWarehouseInput>;
  summaries?: Maybe<WarehouseSummaryUpdateManyWithoutWarehouseInput>;
}

export interface ProductSummarySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductSummaryWhereInput>;
  AND?: Maybe<
    | ProductSummarySubscriptionWhereInput[]
    | ProductSummarySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductSummarySubscriptionWhereInput[]
    | ProductSummarySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductSummarySubscriptionWhereInput[]
    | ProductSummarySubscriptionWhereInput
  >;
}

export interface InventoryItemCreateWithoutWarehouseInput {
  id?: Maybe<ID_Input>;
  productId: ID_Input;
  purchaseOrderId: String;
  deliveryNoteId?: Maybe<String>;
  label?: Maybe<String>;
  expiryDate: DateTimeInput;
  cost?: Maybe<Float>;
}

export interface ExpiryDateSummarySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpiryDateSummaryWhereInput>;
  AND?: Maybe<
    | ExpiryDateSummarySubscriptionWhereInput[]
    | ExpiryDateSummarySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ExpiryDateSummarySubscriptionWhereInput[]
    | ExpiryDateSummarySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ExpiryDateSummarySubscriptionWhereInput[]
    | ExpiryDateSummarySubscriptionWhereInput
  >;
}

export interface WarehouseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  type?: Maybe<WarehouseType>;
  type_not?: Maybe<WarehouseType>;
  type_in?: Maybe<WarehouseType[] | WarehouseType>;
  type_not_in?: Maybe<WarehouseType[] | WarehouseType>;
  products_every?: Maybe<InventoryItemWhereInput>;
  products_some?: Maybe<InventoryItemWhereInput>;
  products_none?: Maybe<InventoryItemWhereInput>;
  summaries_every?: Maybe<WarehouseSummaryWhereInput>;
  summaries_some?: Maybe<WarehouseSummaryWhereInput>;
  summaries_none?: Maybe<WarehouseSummaryWhereInput>;
  AND?: Maybe<WarehouseWhereInput[] | WarehouseWhereInput>;
  OR?: Maybe<WarehouseWhereInput[] | WarehouseWhereInput>;
  NOT?: Maybe<WarehouseWhereInput[] | WarehouseWhereInput>;
}

export interface WarehouseSummaryUpdateManyMutationInput {
  productId?: Maybe<ID_Input>;
  quantity?: Maybe<Int>;
}

export interface ExpiryDateSummaryCreateInput {
  id?: Maybe<ID_Input>;
  productId: ID_Input;
  expiryDate: DateTimeInput;
  quantity: Int;
}

export interface ExpiryDateSummaryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  productId?: Maybe<ID_Input>;
  productId_not?: Maybe<ID_Input>;
  productId_in?: Maybe<ID_Input[] | ID_Input>;
  productId_not_in?: Maybe<ID_Input[] | ID_Input>;
  productId_lt?: Maybe<ID_Input>;
  productId_lte?: Maybe<ID_Input>;
  productId_gt?: Maybe<ID_Input>;
  productId_gte?: Maybe<ID_Input>;
  productId_contains?: Maybe<ID_Input>;
  productId_not_contains?: Maybe<ID_Input>;
  productId_starts_with?: Maybe<ID_Input>;
  productId_not_starts_with?: Maybe<ID_Input>;
  productId_ends_with?: Maybe<ID_Input>;
  productId_not_ends_with?: Maybe<ID_Input>;
  expiryDate?: Maybe<DateTimeInput>;
  expiryDate_not?: Maybe<DateTimeInput>;
  expiryDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_lt?: Maybe<DateTimeInput>;
  expiryDate_lte?: Maybe<DateTimeInput>;
  expiryDate_gt?: Maybe<DateTimeInput>;
  expiryDate_gte?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  AND?: Maybe<ExpiryDateSummaryWhereInput[] | ExpiryDateSummaryWhereInput>;
  OR?: Maybe<ExpiryDateSummaryWhereInput[] | ExpiryDateSummaryWhereInput>;
  NOT?: Maybe<ExpiryDateSummaryWhereInput[] | ExpiryDateSummaryWhereInput>;
}

export interface ExpiryDateSummaryUpdateInput {
  productId?: Maybe<ID_Input>;
  expiryDate?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
}

export interface WarehouseUpdateOneRequiredWithoutSummariesInput {
  create?: Maybe<WarehouseCreateWithoutSummariesInput>;
  update?: Maybe<WarehouseUpdateWithoutSummariesDataInput>;
  upsert?: Maybe<WarehouseUpsertWithoutSummariesInput>;
  connect?: Maybe<WarehouseWhereUniqueInput>;
}

export interface ExpiryDateSummaryUpdateManyMutationInput {
  productId?: Maybe<ID_Input>;
  expiryDate?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
}

export interface WarehouseCreateWithoutSummariesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  address?: Maybe<String>;
  type: WarehouseType;
  products?: Maybe<InventoryItemCreateManyWithoutWarehouseInput>;
}

export interface InventoryItemCreateManyWithoutWarehouseInput {
  create?: Maybe<
    | InventoryItemCreateWithoutWarehouseInput[]
    | InventoryItemCreateWithoutWarehouseInput
  >;
  connect?: Maybe<
    InventoryItemWhereUniqueInput[] | InventoryItemWhereUniqueInput
  >;
}

export interface WarehouseCreateOneWithoutSummariesInput {
  create?: Maybe<WarehouseCreateWithoutSummariesInput>;
  connect?: Maybe<WarehouseWhereUniqueInput>;
}

export interface WarehouseCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  address?: Maybe<String>;
  type: WarehouseType;
  products?: Maybe<InventoryItemCreateManyWithoutWarehouseInput>;
  summaries?: Maybe<WarehouseSummaryCreateManyWithoutWarehouseInput>;
}

export interface WarehouseSummaryCreateInput {
  id?: Maybe<ID_Input>;
  warehouse: WarehouseCreateOneWithoutSummariesInput;
  productId: ID_Input;
  quantity: Int;
}

export interface InventoryItemCreateInput {
  id?: Maybe<ID_Input>;
  warehouse: WarehouseCreateOneWithoutProductsInput;
  productId: ID_Input;
  purchaseOrderId: String;
  deliveryNoteId?: Maybe<String>;
  label?: Maybe<String>;
  expiryDate: DateTimeInput;
  cost?: Maybe<Float>;
}

export interface InventoryItemUpdateManyDataInput {
  productId?: Maybe<ID_Input>;
  purchaseOrderId?: Maybe<String>;
  deliveryNoteId?: Maybe<String>;
  label?: Maybe<String>;
  expiryDate?: Maybe<DateTimeInput>;
  cost?: Maybe<Float>;
}

export interface WarehouseCreateOneWithoutProductsInput {
  create?: Maybe<WarehouseCreateWithoutProductsInput>;
  connect?: Maybe<WarehouseWhereUniqueInput>;
}

export type WarehouseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface WarehouseCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  address?: Maybe<String>;
  type: WarehouseType;
  summaries?: Maybe<WarehouseSummaryCreateManyWithoutWarehouseInput>;
}

export interface InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput {
  where: InventoryItemWhereUniqueInput;
  update: InventoryItemUpdateWithoutWarehouseDataInput;
  create: InventoryItemCreateWithoutWarehouseInput;
}

export interface ProductSummaryUpdateManyMutationInput {
  productId?: Maybe<ID_Input>;
  incomingQuantity?: Maybe<Int>;
  outgoingQuantity?: Maybe<Int>;
  quantity?: Maybe<Int>;
}

export interface WarehouseSummarySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WarehouseSummaryWhereInput>;
  AND?: Maybe<
    | WarehouseSummarySubscriptionWhereInput[]
    | WarehouseSummarySubscriptionWhereInput
  >;
  OR?: Maybe<
    | WarehouseSummarySubscriptionWhereInput[]
    | WarehouseSummarySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | WarehouseSummarySubscriptionWhereInput[]
    | WarehouseSummarySubscriptionWhereInput
  >;
}

export interface WarehouseSummaryCreateWithoutWarehouseInput {
  id?: Maybe<ID_Input>;
  productId: ID_Input;
  quantity: Int;
}

export interface InventoryItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InventoryItemWhereInput>;
  AND?: Maybe<
    InventoryItemSubscriptionWhereInput[] | InventoryItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    InventoryItemSubscriptionWhereInput[] | InventoryItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    InventoryItemSubscriptionWhereInput[] | InventoryItemSubscriptionWhereInput
  >;
}

export interface InventoryItemUpdateInput {
  warehouse?: Maybe<WarehouseUpdateOneRequiredWithoutProductsInput>;
  productId?: Maybe<ID_Input>;
  purchaseOrderId?: Maybe<String>;
  deliveryNoteId?: Maybe<String>;
  label?: Maybe<String>;
  expiryDate?: Maybe<DateTimeInput>;
  cost?: Maybe<Float>;
}

export interface WarehouseSummaryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  warehouse?: Maybe<WarehouseWhereInput>;
  productId?: Maybe<ID_Input>;
  productId_not?: Maybe<ID_Input>;
  productId_in?: Maybe<ID_Input[] | ID_Input>;
  productId_not_in?: Maybe<ID_Input[] | ID_Input>;
  productId_lt?: Maybe<ID_Input>;
  productId_lte?: Maybe<ID_Input>;
  productId_gt?: Maybe<ID_Input>;
  productId_gte?: Maybe<ID_Input>;
  productId_contains?: Maybe<ID_Input>;
  productId_not_contains?: Maybe<ID_Input>;
  productId_starts_with?: Maybe<ID_Input>;
  productId_not_starts_with?: Maybe<ID_Input>;
  productId_ends_with?: Maybe<ID_Input>;
  productId_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  AND?: Maybe<WarehouseSummaryWhereInput[] | WarehouseSummaryWhereInput>;
  OR?: Maybe<WarehouseSummaryWhereInput[] | WarehouseSummaryWhereInput>;
  NOT?: Maybe<WarehouseSummaryWhereInput[] | WarehouseSummaryWhereInput>;
}

export interface WarehouseUpdateOneRequiredWithoutProductsInput {
  create?: Maybe<WarehouseCreateWithoutProductsInput>;
  update?: Maybe<WarehouseUpdateWithoutProductsDataInput>;
  upsert?: Maybe<WarehouseUpsertWithoutProductsInput>;
  connect?: Maybe<WarehouseWhereUniqueInput>;
}

export interface WarehouseUpdateWithoutSummariesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  type?: Maybe<WarehouseType>;
  products?: Maybe<InventoryItemUpdateManyWithoutWarehouseInput>;
}

export interface WarehouseUpdateWithoutProductsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  type?: Maybe<WarehouseType>;
  summaries?: Maybe<WarehouseSummaryUpdateManyWithoutWarehouseInput>;
}

export type ProductSummaryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  productId?: Maybe<ID_Input>;
}>;

export interface ProductSummaryUpdateInput {
  productId?: Maybe<ID_Input>;
  incomingQuantity?: Maybe<Int>;
  outgoingQuantity?: Maybe<Int>;
  quantity?: Maybe<Int>;
}

export interface WarehouseUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  address?: Maybe<String>;
  type?: Maybe<WarehouseType>;
}

export interface WarehouseSummaryUpdateWithWhereUniqueWithoutWarehouseInput {
  where: WarehouseSummaryWhereUniqueInput;
  data: WarehouseSummaryUpdateWithoutWarehouseDataInput;
}

export interface InventoryItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  productId?: Maybe<ID_Input>;
  productId_not?: Maybe<ID_Input>;
  productId_in?: Maybe<ID_Input[] | ID_Input>;
  productId_not_in?: Maybe<ID_Input[] | ID_Input>;
  productId_lt?: Maybe<ID_Input>;
  productId_lte?: Maybe<ID_Input>;
  productId_gt?: Maybe<ID_Input>;
  productId_gte?: Maybe<ID_Input>;
  productId_contains?: Maybe<ID_Input>;
  productId_not_contains?: Maybe<ID_Input>;
  productId_starts_with?: Maybe<ID_Input>;
  productId_not_starts_with?: Maybe<ID_Input>;
  productId_ends_with?: Maybe<ID_Input>;
  productId_not_ends_with?: Maybe<ID_Input>;
  purchaseOrderId?: Maybe<String>;
  purchaseOrderId_not?: Maybe<String>;
  purchaseOrderId_in?: Maybe<String[] | String>;
  purchaseOrderId_not_in?: Maybe<String[] | String>;
  purchaseOrderId_lt?: Maybe<String>;
  purchaseOrderId_lte?: Maybe<String>;
  purchaseOrderId_gt?: Maybe<String>;
  purchaseOrderId_gte?: Maybe<String>;
  purchaseOrderId_contains?: Maybe<String>;
  purchaseOrderId_not_contains?: Maybe<String>;
  purchaseOrderId_starts_with?: Maybe<String>;
  purchaseOrderId_not_starts_with?: Maybe<String>;
  purchaseOrderId_ends_with?: Maybe<String>;
  purchaseOrderId_not_ends_with?: Maybe<String>;
  deliveryNoteId?: Maybe<String>;
  deliveryNoteId_not?: Maybe<String>;
  deliveryNoteId_in?: Maybe<String[] | String>;
  deliveryNoteId_not_in?: Maybe<String[] | String>;
  deliveryNoteId_lt?: Maybe<String>;
  deliveryNoteId_lte?: Maybe<String>;
  deliveryNoteId_gt?: Maybe<String>;
  deliveryNoteId_gte?: Maybe<String>;
  deliveryNoteId_contains?: Maybe<String>;
  deliveryNoteId_not_contains?: Maybe<String>;
  deliveryNoteId_starts_with?: Maybe<String>;
  deliveryNoteId_not_starts_with?: Maybe<String>;
  deliveryNoteId_ends_with?: Maybe<String>;
  deliveryNoteId_not_ends_with?: Maybe<String>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  expiryDate?: Maybe<DateTimeInput>;
  expiryDate_not?: Maybe<DateTimeInput>;
  expiryDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_lt?: Maybe<DateTimeInput>;
  expiryDate_lte?: Maybe<DateTimeInput>;
  expiryDate_gt?: Maybe<DateTimeInput>;
  expiryDate_gte?: Maybe<DateTimeInput>;
  cost?: Maybe<Float>;
  cost_not?: Maybe<Float>;
  cost_in?: Maybe<Float[] | Float>;
  cost_not_in?: Maybe<Float[] | Float>;
  cost_lt?: Maybe<Float>;
  cost_lte?: Maybe<Float>;
  cost_gt?: Maybe<Float>;
  cost_gte?: Maybe<Float>;
  AND?: Maybe<InventoryItemScalarWhereInput[] | InventoryItemScalarWhereInput>;
  OR?: Maybe<InventoryItemScalarWhereInput[] | InventoryItemScalarWhereInput>;
  NOT?: Maybe<InventoryItemScalarWhereInput[] | InventoryItemScalarWhereInput>;
}

export interface WarehouseSummaryUpdateWithoutWarehouseDataInput {
  productId?: Maybe<ID_Input>;
  quantity?: Maybe<Int>;
}

export type InventoryItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WarehouseSummaryUpsertWithWhereUniqueWithoutWarehouseInput {
  where: WarehouseSummaryWhereUniqueInput;
  update: WarehouseSummaryUpdateWithoutWarehouseDataInput;
  create: WarehouseSummaryCreateWithoutWarehouseInput;
}

export interface WarehouseUpsertWithoutSummariesInput {
  update: WarehouseUpdateWithoutSummariesDataInput;
  create: WarehouseCreateWithoutSummariesInput;
}

export interface WarehouseSummaryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  productId?: Maybe<ID_Input>;
  productId_not?: Maybe<ID_Input>;
  productId_in?: Maybe<ID_Input[] | ID_Input>;
  productId_not_in?: Maybe<ID_Input[] | ID_Input>;
  productId_lt?: Maybe<ID_Input>;
  productId_lte?: Maybe<ID_Input>;
  productId_gt?: Maybe<ID_Input>;
  productId_gte?: Maybe<ID_Input>;
  productId_contains?: Maybe<ID_Input>;
  productId_not_contains?: Maybe<ID_Input>;
  productId_starts_with?: Maybe<ID_Input>;
  productId_not_starts_with?: Maybe<ID_Input>;
  productId_ends_with?: Maybe<ID_Input>;
  productId_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  AND?: Maybe<
    WarehouseSummaryScalarWhereInput[] | WarehouseSummaryScalarWhereInput
  >;
  OR?: Maybe<
    WarehouseSummaryScalarWhereInput[] | WarehouseSummaryScalarWhereInput
  >;
  NOT?: Maybe<
    WarehouseSummaryScalarWhereInput[] | WarehouseSummaryScalarWhereInput
  >;
}

export interface ProductSummaryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  productId?: Maybe<ID_Input>;
  productId_not?: Maybe<ID_Input>;
  productId_in?: Maybe<ID_Input[] | ID_Input>;
  productId_not_in?: Maybe<ID_Input[] | ID_Input>;
  productId_lt?: Maybe<ID_Input>;
  productId_lte?: Maybe<ID_Input>;
  productId_gt?: Maybe<ID_Input>;
  productId_gte?: Maybe<ID_Input>;
  productId_contains?: Maybe<ID_Input>;
  productId_not_contains?: Maybe<ID_Input>;
  productId_starts_with?: Maybe<ID_Input>;
  productId_not_starts_with?: Maybe<ID_Input>;
  productId_ends_with?: Maybe<ID_Input>;
  productId_not_ends_with?: Maybe<ID_Input>;
  incomingQuantity?: Maybe<Int>;
  incomingQuantity_not?: Maybe<Int>;
  incomingQuantity_in?: Maybe<Int[] | Int>;
  incomingQuantity_not_in?: Maybe<Int[] | Int>;
  incomingQuantity_lt?: Maybe<Int>;
  incomingQuantity_lte?: Maybe<Int>;
  incomingQuantity_gt?: Maybe<Int>;
  incomingQuantity_gte?: Maybe<Int>;
  outgoingQuantity?: Maybe<Int>;
  outgoingQuantity_not?: Maybe<Int>;
  outgoingQuantity_in?: Maybe<Int[] | Int>;
  outgoingQuantity_not_in?: Maybe<Int[] | Int>;
  outgoingQuantity_lt?: Maybe<Int>;
  outgoingQuantity_lte?: Maybe<Int>;
  outgoingQuantity_gt?: Maybe<Int>;
  outgoingQuantity_gte?: Maybe<Int>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  AND?: Maybe<ProductSummaryWhereInput[] | ProductSummaryWhereInput>;
  OR?: Maybe<ProductSummaryWhereInput[] | ProductSummaryWhereInput>;
  NOT?: Maybe<ProductSummaryWhereInput[] | ProductSummaryWhereInput>;
}

export interface InventoryItemUpdateManyMutationInput {
  productId?: Maybe<ID_Input>;
  purchaseOrderId?: Maybe<String>;
  deliveryNoteId?: Maybe<String>;
  label?: Maybe<String>;
  expiryDate?: Maybe<DateTimeInput>;
  cost?: Maybe<Float>;
}

export interface WarehouseUpsertWithoutProductsInput {
  update: WarehouseUpdateWithoutProductsDataInput;
  create: WarehouseCreateWithoutProductsInput;
}

export interface WarehouseSummaryUpdateManyDataInput {
  productId?: Maybe<ID_Input>;
  quantity?: Maybe<Int>;
}

export interface WarehouseSummaryUpdateManyWithWhereNestedInput {
  where: WarehouseSummaryScalarWhereInput;
  data: WarehouseSummaryUpdateManyDataInput;
}

export interface InventoryItemUpdateManyWithWhereNestedInput {
  where: InventoryItemScalarWhereInput;
  data: InventoryItemUpdateManyDataInput;
}

export interface WarehouseSummaryUpdateInput {
  warehouse?: Maybe<WarehouseUpdateOneRequiredWithoutSummariesInput>;
  productId?: Maybe<ID_Input>;
  quantity?: Maybe<Int>;
}

export interface InventoryItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  warehouse?: Maybe<WarehouseWhereInput>;
  productId?: Maybe<ID_Input>;
  productId_not?: Maybe<ID_Input>;
  productId_in?: Maybe<ID_Input[] | ID_Input>;
  productId_not_in?: Maybe<ID_Input[] | ID_Input>;
  productId_lt?: Maybe<ID_Input>;
  productId_lte?: Maybe<ID_Input>;
  productId_gt?: Maybe<ID_Input>;
  productId_gte?: Maybe<ID_Input>;
  productId_contains?: Maybe<ID_Input>;
  productId_not_contains?: Maybe<ID_Input>;
  productId_starts_with?: Maybe<ID_Input>;
  productId_not_starts_with?: Maybe<ID_Input>;
  productId_ends_with?: Maybe<ID_Input>;
  productId_not_ends_with?: Maybe<ID_Input>;
  purchaseOrderId?: Maybe<String>;
  purchaseOrderId_not?: Maybe<String>;
  purchaseOrderId_in?: Maybe<String[] | String>;
  purchaseOrderId_not_in?: Maybe<String[] | String>;
  purchaseOrderId_lt?: Maybe<String>;
  purchaseOrderId_lte?: Maybe<String>;
  purchaseOrderId_gt?: Maybe<String>;
  purchaseOrderId_gte?: Maybe<String>;
  purchaseOrderId_contains?: Maybe<String>;
  purchaseOrderId_not_contains?: Maybe<String>;
  purchaseOrderId_starts_with?: Maybe<String>;
  purchaseOrderId_not_starts_with?: Maybe<String>;
  purchaseOrderId_ends_with?: Maybe<String>;
  purchaseOrderId_not_ends_with?: Maybe<String>;
  deliveryNoteId?: Maybe<String>;
  deliveryNoteId_not?: Maybe<String>;
  deliveryNoteId_in?: Maybe<String[] | String>;
  deliveryNoteId_not_in?: Maybe<String[] | String>;
  deliveryNoteId_lt?: Maybe<String>;
  deliveryNoteId_lte?: Maybe<String>;
  deliveryNoteId_gt?: Maybe<String>;
  deliveryNoteId_gte?: Maybe<String>;
  deliveryNoteId_contains?: Maybe<String>;
  deliveryNoteId_not_contains?: Maybe<String>;
  deliveryNoteId_starts_with?: Maybe<String>;
  deliveryNoteId_not_starts_with?: Maybe<String>;
  deliveryNoteId_ends_with?: Maybe<String>;
  deliveryNoteId_not_ends_with?: Maybe<String>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  expiryDate?: Maybe<DateTimeInput>;
  expiryDate_not?: Maybe<DateTimeInput>;
  expiryDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiryDate_lt?: Maybe<DateTimeInput>;
  expiryDate_lte?: Maybe<DateTimeInput>;
  expiryDate_gt?: Maybe<DateTimeInput>;
  expiryDate_gte?: Maybe<DateTimeInput>;
  cost?: Maybe<Float>;
  cost_not?: Maybe<Float>;
  cost_in?: Maybe<Float[] | Float>;
  cost_not_in?: Maybe<Float[] | Float>;
  cost_lt?: Maybe<Float>;
  cost_lte?: Maybe<Float>;
  cost_gt?: Maybe<Float>;
  cost_gte?: Maybe<Float>;
  AND?: Maybe<InventoryItemWhereInput[] | InventoryItemWhereInput>;
  OR?: Maybe<InventoryItemWhereInput[] | InventoryItemWhereInput>;
  NOT?: Maybe<InventoryItemWhereInput[] | InventoryItemWhereInput>;
}

export interface InventoryItemUpdateWithoutWarehouseDataInput {
  productId?: Maybe<ID_Input>;
  purchaseOrderId?: Maybe<String>;
  deliveryNoteId?: Maybe<String>;
  label?: Maybe<String>;
  expiryDate?: Maybe<DateTimeInput>;
  cost?: Maybe<Float>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WarehouseSummaryPreviousValues {
  id: ID_Output;
  productId: ID_Output;
  quantity: Int;
}

export interface WarehouseSummaryPreviousValuesPromise
  extends Promise<WarehouseSummaryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productId: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
}

export interface WarehouseSummaryPreviousValuesSubscription
  extends Promise<AsyncIterator<WarehouseSummaryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  productId: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface WarehouseSummary {
  id: ID_Output;
  productId: ID_Output;
  quantity: Int;
}

export interface WarehouseSummaryPromise
  extends Promise<WarehouseSummary>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  warehouse: <T = WarehousePromise>() => T;
  productId: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
}

export interface WarehouseSummarySubscription
  extends Promise<AsyncIterator<WarehouseSummary>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  warehouse: <T = WarehouseSubscription>() => T;
  productId: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface WarehouseSummaryNullablePromise
  extends Promise<WarehouseSummary | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  warehouse: <T = WarehousePromise>() => T;
  productId: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface InventoryItemConnection {
  pageInfo: PageInfo;
  edges: InventoryItemEdge[];
}

export interface InventoryItemConnectionPromise
  extends Promise<InventoryItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryItemEdge>>() => T;
  aggregate: <T = AggregateInventoryItemPromise>() => T;
}

export interface InventoryItemConnectionSubscription
  extends Promise<AsyncIterator<InventoryItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventoryItemSubscription>() => T;
}

export interface AggregateExpiryDateSummary {
  count: Int;
}

export interface AggregateExpiryDateSummaryPromise
  extends Promise<AggregateExpiryDateSummary>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpiryDateSummarySubscription
  extends Promise<AsyncIterator<AggregateExpiryDateSummary>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WarehousePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  address?: String;
  type: WarehouseType;
}

export interface WarehousePreviousValuesPromise
  extends Promise<WarehousePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  address: () => Promise<String>;
  type: () => Promise<WarehouseType>;
}

export interface WarehousePreviousValuesSubscription
  extends Promise<AsyncIterator<WarehousePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<WarehouseType>>;
}

export interface WarehouseSummaryEdge {
  node: WarehouseSummary;
  cursor: String;
}

export interface WarehouseSummaryEdgePromise
  extends Promise<WarehouseSummaryEdge>,
    Fragmentable {
  node: <T = WarehouseSummaryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WarehouseSummaryEdgeSubscription
  extends Promise<AsyncIterator<WarehouseSummaryEdge>>,
    Fragmentable {
  node: <T = WarehouseSummarySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateWarehouse {
  count: Int;
}

export interface AggregateWarehousePromise
  extends Promise<AggregateWarehouse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWarehouseSubscription
  extends Promise<AsyncIterator<AggregateWarehouse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WarehouseSubscriptionPayload {
  mutation: MutationType;
  node: Warehouse;
  updatedFields: String[];
  previousValues: WarehousePreviousValues;
}

export interface WarehouseSubscriptionPayloadPromise
  extends Promise<WarehouseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WarehousePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WarehousePreviousValuesPromise>() => T;
}

export interface WarehouseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WarehouseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WarehouseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WarehousePreviousValuesSubscription>() => T;
}

export interface WarehouseConnection {
  pageInfo: PageInfo;
  edges: WarehouseEdge[];
}

export interface WarehouseConnectionPromise
  extends Promise<WarehouseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WarehouseEdge>>() => T;
  aggregate: <T = AggregateWarehousePromise>() => T;
}

export interface WarehouseConnectionSubscription
  extends Promise<AsyncIterator<WarehouseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WarehouseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWarehouseSubscription>() => T;
}

export interface ExpiryDateSummaryConnection {
  pageInfo: PageInfo;
  edges: ExpiryDateSummaryEdge[];
}

export interface ExpiryDateSummaryConnectionPromise
  extends Promise<ExpiryDateSummaryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpiryDateSummaryEdge>>() => T;
  aggregate: <T = AggregateExpiryDateSummaryPromise>() => T;
}

export interface ExpiryDateSummaryConnectionSubscription
  extends Promise<AsyncIterator<ExpiryDateSummaryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpiryDateSummaryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpiryDateSummarySubscription>() => T;
}

export interface AggregateProductSummary {
  count: Int;
}

export interface AggregateProductSummaryPromise
  extends Promise<AggregateProductSummary>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSummarySubscription
  extends Promise<AsyncIterator<AggregateProductSummary>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpiryDateSummary {
  id: ID_Output;
  productId: ID_Output;
  expiryDate: DateTimeOutput;
  quantity: Int;
}

export interface ExpiryDateSummaryPromise
  extends Promise<ExpiryDateSummary>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productId: () => Promise<ID_Output>;
  expiryDate: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
}

export interface ExpiryDateSummarySubscription
  extends Promise<AsyncIterator<ExpiryDateSummary>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  productId: () => Promise<AsyncIterator<ID_Output>>;
  expiryDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface ExpiryDateSummaryNullablePromise
  extends Promise<ExpiryDateSummary | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productId: () => Promise<ID_Output>;
  expiryDate: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
}

export interface ProductSummaryConnection {
  pageInfo: PageInfo;
  edges: ProductSummaryEdge[];
}

export interface ProductSummaryConnectionPromise
  extends Promise<ProductSummaryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductSummaryEdge>>() => T;
  aggregate: <T = AggregateProductSummaryPromise>() => T;
}

export interface ProductSummaryConnectionSubscription
  extends Promise<AsyncIterator<ProductSummaryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductSummaryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSummarySubscription>() => T;
}

export interface ExpiryDateSummarySubscriptionPayload {
  mutation: MutationType;
  node: ExpiryDateSummary;
  updatedFields: String[];
  previousValues: ExpiryDateSummaryPreviousValues;
}

export interface ExpiryDateSummarySubscriptionPayloadPromise
  extends Promise<ExpiryDateSummarySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpiryDateSummaryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpiryDateSummaryPreviousValuesPromise>() => T;
}

export interface ExpiryDateSummarySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpiryDateSummarySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpiryDateSummarySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpiryDateSummaryPreviousValuesSubscription>() => T;
}

export interface ProductSummary {
  id: ID_Output;
  productId: ID_Output;
  incomingQuantity: Int;
  outgoingQuantity: Int;
  quantity: Int;
}

export interface ProductSummaryPromise
  extends Promise<ProductSummary>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productId: () => Promise<ID_Output>;
  incomingQuantity: () => Promise<Int>;
  outgoingQuantity: () => Promise<Int>;
  quantity: () => Promise<Int>;
}

export interface ProductSummarySubscription
  extends Promise<AsyncIterator<ProductSummary>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  productId: () => Promise<AsyncIterator<ID_Output>>;
  incomingQuantity: () => Promise<AsyncIterator<Int>>;
  outgoingQuantity: () => Promise<AsyncIterator<Int>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface ProductSummaryNullablePromise
  extends Promise<ProductSummary | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productId: () => Promise<ID_Output>;
  incomingQuantity: () => Promise<Int>;
  outgoingQuantity: () => Promise<Int>;
  quantity: () => Promise<Int>;
}

export interface ExpiryDateSummaryPreviousValues {
  id: ID_Output;
  productId: ID_Output;
  expiryDate: DateTimeOutput;
  quantity: Int;
}

export interface ExpiryDateSummaryPreviousValuesPromise
  extends Promise<ExpiryDateSummaryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productId: () => Promise<ID_Output>;
  expiryDate: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
}

export interface ExpiryDateSummaryPreviousValuesSubscription
  extends Promise<AsyncIterator<ExpiryDateSummaryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  productId: () => Promise<AsyncIterator<ID_Output>>;
  expiryDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface InventoryItemEdge {
  node: InventoryItem;
  cursor: String;
}

export interface InventoryItemEdgePromise
  extends Promise<InventoryItemEdge>,
    Fragmentable {
  node: <T = InventoryItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryItemEdgeSubscription
  extends Promise<AsyncIterator<InventoryItemEdge>>,
    Fragmentable {
  node: <T = InventoryItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Warehouse {
  id: ID_Output;
  name: String;
  description?: String;
  address?: String;
  type: WarehouseType;
}

export interface WarehousePromise extends Promise<Warehouse>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  address: () => Promise<String>;
  type: () => Promise<WarehouseType>;
  products: <T = FragmentableArray<InventoryItem>>(args?: {
    where?: InventoryItemWhereInput;
    orderBy?: InventoryItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  summaries: <T = FragmentableArray<WarehouseSummary>>(args?: {
    where?: WarehouseSummaryWhereInput;
    orderBy?: WarehouseSummaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WarehouseSubscription
  extends Promise<AsyncIterator<Warehouse>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<WarehouseType>>;
  products: <T = Promise<AsyncIterator<InventoryItemSubscription>>>(args?: {
    where?: InventoryItemWhereInput;
    orderBy?: InventoryItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  summaries: <T = Promise<AsyncIterator<WarehouseSummarySubscription>>>(args?: {
    where?: WarehouseSummaryWhereInput;
    orderBy?: WarehouseSummaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WarehouseNullablePromise
  extends Promise<Warehouse | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  address: () => Promise<String>;
  type: () => Promise<WarehouseType>;
  products: <T = FragmentableArray<InventoryItem>>(args?: {
    where?: InventoryItemWhereInput;
    orderBy?: InventoryItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  summaries: <T = FragmentableArray<WarehouseSummary>>(args?: {
    where?: WarehouseSummaryWhereInput;
    orderBy?: WarehouseSummaryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WarehouseSummaryConnection {
  pageInfo: PageInfo;
  edges: WarehouseSummaryEdge[];
}

export interface WarehouseSummaryConnectionPromise
  extends Promise<WarehouseSummaryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WarehouseSummaryEdge>>() => T;
  aggregate: <T = AggregateWarehouseSummaryPromise>() => T;
}

export interface WarehouseSummaryConnectionSubscription
  extends Promise<AsyncIterator<WarehouseSummaryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WarehouseSummaryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWarehouseSummarySubscription>() => T;
}

export interface InventoryItemSubscriptionPayload {
  mutation: MutationType;
  node: InventoryItem;
  updatedFields: String[];
  previousValues: InventoryItemPreviousValues;
}

export interface InventoryItemSubscriptionPayloadPromise
  extends Promise<InventoryItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryItemPreviousValuesPromise>() => T;
}

export interface InventoryItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventoryItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventoryItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryItemPreviousValuesSubscription>() => T;
}

export interface WarehouseSummarySubscriptionPayload {
  mutation: MutationType;
  node: WarehouseSummary;
  updatedFields: String[];
  previousValues: WarehouseSummaryPreviousValues;
}

export interface WarehouseSummarySubscriptionPayloadPromise
  extends Promise<WarehouseSummarySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WarehouseSummaryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WarehouseSummaryPreviousValuesPromise>() => T;
}

export interface WarehouseSummarySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WarehouseSummarySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WarehouseSummarySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WarehouseSummaryPreviousValuesSubscription>() => T;
}

export interface ProductSummaryPreviousValues {
  id: ID_Output;
  productId: ID_Output;
  incomingQuantity: Int;
  outgoingQuantity: Int;
  quantity: Int;
}

export interface ProductSummaryPreviousValuesPromise
  extends Promise<ProductSummaryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productId: () => Promise<ID_Output>;
  incomingQuantity: () => Promise<Int>;
  outgoingQuantity: () => Promise<Int>;
  quantity: () => Promise<Int>;
}

export interface ProductSummaryPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductSummaryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  productId: () => Promise<AsyncIterator<ID_Output>>;
  incomingQuantity: () => Promise<AsyncIterator<Int>>;
  outgoingQuantity: () => Promise<AsyncIterator<Int>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface ProductSummarySubscriptionPayload {
  mutation: MutationType;
  node: ProductSummary;
  updatedFields: String[];
  previousValues: ProductSummaryPreviousValues;
}

export interface ProductSummarySubscriptionPayloadPromise
  extends Promise<ProductSummarySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductSummaryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductSummaryPreviousValuesPromise>() => T;
}

export interface ProductSummarySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSummarySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSummarySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductSummaryPreviousValuesSubscription>() => T;
}

export interface InventoryItem {
  id: ID_Output;
  productId: ID_Output;
  purchaseOrderId: String;
  deliveryNoteId?: String;
  label?: String;
  expiryDate: DateTimeOutput;
  cost?: Float;
}

export interface InventoryItemPromise
  extends Promise<InventoryItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  warehouse: <T = WarehousePromise>() => T;
  productId: () => Promise<ID_Output>;
  purchaseOrderId: () => Promise<String>;
  deliveryNoteId: () => Promise<String>;
  label: () => Promise<String>;
  expiryDate: () => Promise<DateTimeOutput>;
  cost: () => Promise<Float>;
}

export interface InventoryItemSubscription
  extends Promise<AsyncIterator<InventoryItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  warehouse: <T = WarehouseSubscription>() => T;
  productId: () => Promise<AsyncIterator<ID_Output>>;
  purchaseOrderId: () => Promise<AsyncIterator<String>>;
  deliveryNoteId: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  expiryDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  cost: () => Promise<AsyncIterator<Float>>;
}

export interface InventoryItemNullablePromise
  extends Promise<InventoryItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  warehouse: <T = WarehousePromise>() => T;
  productId: () => Promise<ID_Output>;
  purchaseOrderId: () => Promise<String>;
  deliveryNoteId: () => Promise<String>;
  label: () => Promise<String>;
  expiryDate: () => Promise<DateTimeOutput>;
  cost: () => Promise<Float>;
}

export interface InventoryItemPreviousValues {
  id: ID_Output;
  productId: ID_Output;
  purchaseOrderId: String;
  deliveryNoteId?: String;
  label?: String;
  expiryDate: DateTimeOutput;
  cost?: Float;
}

export interface InventoryItemPreviousValuesPromise
  extends Promise<InventoryItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productId: () => Promise<ID_Output>;
  purchaseOrderId: () => Promise<String>;
  deliveryNoteId: () => Promise<String>;
  label: () => Promise<String>;
  expiryDate: () => Promise<DateTimeOutput>;
  cost: () => Promise<Float>;
}

export interface InventoryItemPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  productId: () => Promise<AsyncIterator<ID_Output>>;
  purchaseOrderId: () => Promise<AsyncIterator<String>>;
  deliveryNoteId: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  expiryDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  cost: () => Promise<AsyncIterator<Float>>;
}

export interface ProductSummaryEdge {
  node: ProductSummary;
  cursor: String;
}

export interface ProductSummaryEdgePromise
  extends Promise<ProductSummaryEdge>,
    Fragmentable {
  node: <T = ProductSummaryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductSummaryEdgeSubscription
  extends Promise<AsyncIterator<ProductSummaryEdge>>,
    Fragmentable {
  node: <T = ProductSummarySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface WarehouseEdge {
  node: Warehouse;
  cursor: String;
}

export interface WarehouseEdgePromise
  extends Promise<WarehouseEdge>,
    Fragmentable {
  node: <T = WarehousePromise>() => T;
  cursor: () => Promise<String>;
}

export interface WarehouseEdgeSubscription
  extends Promise<AsyncIterator<WarehouseEdge>>,
    Fragmentable {
  node: <T = WarehouseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWarehouseSummary {
  count: Int;
}

export interface AggregateWarehouseSummaryPromise
  extends Promise<AggregateWarehouseSummary>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWarehouseSummarySubscription
  extends Promise<AsyncIterator<AggregateWarehouseSummary>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateInventoryItem {
  count: Int;
}

export interface AggregateInventoryItemPromise
  extends Promise<AggregateInventoryItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventoryItemSubscription
  extends Promise<AsyncIterator<AggregateInventoryItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpiryDateSummaryEdge {
  node: ExpiryDateSummary;
  cursor: String;
}

export interface ExpiryDateSummaryEdgePromise
  extends Promise<ExpiryDateSummaryEdge>,
    Fragmentable {
  node: <T = ExpiryDateSummaryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpiryDateSummaryEdgeSubscription
  extends Promise<AsyncIterator<ExpiryDateSummaryEdge>>,
    Fragmentable {
  node: <T = ExpiryDateSummarySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Warehouse",
    embedded: false
  },
  {
    name: "WarehouseType",
    embedded: false
  },
  {
    name: "InventoryItem",
    embedded: false
  },
  {
    name: "ProductSummary",
    embedded: false
  },
  {
    name: "WarehouseSummary",
    embedded: false
  },
  {
    name: "ExpiryDateSummary",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
