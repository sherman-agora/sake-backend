// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  product: (where?: ProductWhereInput) => Promise<boolean>;
  productCategory: (where?: ProductCategoryWhereInput) => Promise<boolean>;
  productImage: (where?: ProductImageWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  productCategory: (
    where: ProductCategoryWhereUniqueInput
  ) => ProductCategoryNullablePromise;
  productCategories: (args?: {
    where?: ProductCategoryWhereInput;
    orderBy?: ProductCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductCategory>;
  productCategoriesConnection: (args?: {
    where?: ProductCategoryWhereInput;
    orderBy?: ProductCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductCategoryConnectionPromise;
  productImages: (args?: {
    where?: ProductImageWhereInput;
    orderBy?: ProductImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductImage>;
  productImagesConnection: (args?: {
    where?: ProductImageWhereInput;
    orderBy?: ProductImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductImageConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProductCategory: (
    data: ProductCategoryCreateInput
  ) => ProductCategoryPromise;
  updateProductCategory: (args: {
    data: ProductCategoryUpdateInput;
    where: ProductCategoryWhereUniqueInput;
  }) => ProductCategoryPromise;
  updateManyProductCategories: (args: {
    data: ProductCategoryUpdateManyMutationInput;
    where?: ProductCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertProductCategory: (args: {
    where: ProductCategoryWhereUniqueInput;
    create: ProductCategoryCreateInput;
    update: ProductCategoryUpdateInput;
  }) => ProductCategoryPromise;
  deleteProductCategory: (
    where: ProductCategoryWhereUniqueInput
  ) => ProductCategoryPromise;
  deleteManyProductCategories: (
    where?: ProductCategoryWhereInput
  ) => BatchPayloadPromise;
  createProductImage: (data: ProductImageCreateInput) => ProductImagePromise;
  updateManyProductImages: (args: {
    data: ProductImageUpdateManyMutationInput;
    where?: ProductImageWhereInput;
  }) => BatchPayloadPromise;
  deleteManyProductImages: (
    where?: ProductImageWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  productCategory: (
    where?: ProductCategorySubscriptionWhereInput
  ) => ProductCategorySubscriptionPayloadSubscription;
  productImage: (
    where?: ProductImageSubscriptionWhereInput
  ) => ProductImageSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ProductImageOrderByInput =
  | "src_ASC"
  | "src_DESC"
  | "title_ASC"
  | "title_DESC";

export type ProductCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nameEn_ASC"
  | "nameEn_DESC"
  | "nameChi_ASC"
  | "nameChi_DESC"
  | "detail_ASC"
  | "detail_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "brandEn_ASC"
  | "brandEn_DESC"
  | "brandChi_ASC"
  | "brandChi_DESC"
  | "nameEn_ASC"
  | "nameEn_DESC"
  | "nameChi_ASC"
  | "nameChi_DESC"
  | "discount_ASC"
  | "discount_DESC"
  | "package_ASC"
  | "package_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC"
  | "longDescription_ASC"
  | "longDescription_DESC"
  | "sku_ASC"
  | "sku_DESC"
  | "upc_ASC"
  | "upc_DESC"
  | "cost_ASC"
  | "cost_DESC"
  | "printInLabel_ASC"
  | "printInLabel_DESC"
  | "printInInvoice_ASC"
  | "printInInvoice_DESC"
  | "printInDN_ASC"
  | "printInDN_DESC"
  | "wholeSalePrice1_ASC"
  | "wholeSalePrice1_DESC"
  | "wholeSalePrice2_ASC"
  | "wholeSalePrice2_DESC"
  | "wholeSalePrice3_ASC"
  | "wholeSalePrice3_DESC"
  | "wholeSalePrice4_ASC"
  | "wholeSalePrice4_DESC"
  | "wholeSalePrice5_ASC"
  | "wholeSalePrice5_DESC"
  | "retailPrice1_ASC"
  | "retailPrice1_DESC"
  | "retailPrice2_ASC"
  | "retailPrice2_DESC"
  | "retailPrice3_ASC"
  | "retailPrice3_DESC"
  | "retailPrice4_ASC"
  | "retailPrice4_DESC"
  | "retailPrice5_ASC"
  | "retailPrice5_DESC"
  | "minOrderQuantity_ASC"
  | "minOrderQuantity_DESC"
  | "minStockLevel_ASC"
  | "minStockLevel_DESC"
  | "onlineDate_ASC"
  | "onlineDate_DESC"
  | "offlineDate_ASC"
  | "offlineDate_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface ProductImageScalarWhereInput {
  src?: Maybe<String>;
  src_not?: Maybe<String>;
  src_in?: Maybe<String[] | String>;
  src_not_in?: Maybe<String[] | String>;
  src_lt?: Maybe<String>;
  src_lte?: Maybe<String>;
  src_gt?: Maybe<String>;
  src_gte?: Maybe<String>;
  src_contains?: Maybe<String>;
  src_not_contains?: Maybe<String>;
  src_starts_with?: Maybe<String>;
  src_not_starts_with?: Maybe<String>;
  src_ends_with?: Maybe<String>;
  src_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductImageScalarWhereInput[] | ProductImageScalarWhereInput>;
  OR?: Maybe<ProductImageScalarWhereInput[] | ProductImageScalarWhereInput>;
  NOT?: Maybe<ProductImageScalarWhereInput[] | ProductImageScalarWhereInput>;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
}>;

export interface ProductCategoryUpdateManyWithoutProductsInput {
  create?: Maybe<
    | ProductCategoryCreateWithoutProductsInput[]
    | ProductCategoryCreateWithoutProductsInput
  >;
  delete?: Maybe<
    ProductCategoryWhereUniqueInput[] | ProductCategoryWhereUniqueInput
  >;
  connect?: Maybe<
    ProductCategoryWhereUniqueInput[] | ProductCategoryWhereUniqueInput
  >;
  set?: Maybe<
    ProductCategoryWhereUniqueInput[] | ProductCategoryWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProductCategoryWhereUniqueInput[] | ProductCategoryWhereUniqueInput
  >;
  update?: Maybe<
    | ProductCategoryUpdateWithWhereUniqueWithoutProductsInput[]
    | ProductCategoryUpdateWithWhereUniqueWithoutProductsInput
  >;
  upsert?: Maybe<
    | ProductCategoryUpsertWithWhereUniqueWithoutProductsInput[]
    | ProductCategoryUpsertWithWhereUniqueWithoutProductsInput
  >;
  deleteMany?: Maybe<
    ProductCategoryScalarWhereInput[] | ProductCategoryScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductCategoryUpdateManyWithWhereNestedInput[]
    | ProductCategoryUpdateManyWithWhereNestedInput
  >;
}

export interface ProductImageWhereInput {
  src?: Maybe<String>;
  src_not?: Maybe<String>;
  src_in?: Maybe<String[] | String>;
  src_not_in?: Maybe<String[] | String>;
  src_lt?: Maybe<String>;
  src_lte?: Maybe<String>;
  src_gt?: Maybe<String>;
  src_gte?: Maybe<String>;
  src_contains?: Maybe<String>;
  src_not_contains?: Maybe<String>;
  src_starts_with?: Maybe<String>;
  src_not_starts_with?: Maybe<String>;
  src_ends_with?: Maybe<String>;
  src_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductImageWhereInput[] | ProductImageWhereInput>;
  OR?: Maybe<ProductImageWhereInput[] | ProductImageWhereInput>;
  NOT?: Maybe<ProductImageWhereInput[] | ProductImageWhereInput>;
}

export interface ProductCategoryUpdateManyDataInput {
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  detail?: Maybe<String>;
}

export interface ProductCategoryUpdateWithWhereUniqueWithoutProductsInput {
  where: ProductCategoryWhereUniqueInput;
  data: ProductCategoryUpdateWithoutProductsDataInput;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  brandEn: String;
  brandChi: String;
  nameEn: String;
  nameChi: String;
  discount?: Maybe<String>;
  package: Int;
  weight: String;
  shortDescription?: Maybe<String>;
  longDescription?: Maybe<String>;
  images?: Maybe<ProductImageCreateManyInput>;
  sku?: Maybe<String>;
  upc: String;
  cost: Float;
  printInLabel?: Maybe<Boolean>;
  printInInvoice?: Maybe<Boolean>;
  printInDN?: Maybe<Boolean>;
  wholeSalePrice1: Float;
  wholeSalePrice2: Float;
  wholeSalePrice3: Float;
  wholeSalePrice4: Float;
  wholeSalePrice5: Float;
  retailPrice1: Float;
  retailPrice2: Float;
  retailPrice3: Float;
  retailPrice4: Float;
  retailPrice5: Float;
  minOrderQuantity?: Maybe<Float>;
  minStockLevel?: Maybe<Float>;
  onlineDate?: Maybe<DateTimeInput>;
  offlineDate?: Maybe<DateTimeInput>;
  categories?: Maybe<ProductCategoryCreateManyWithoutProductsInput>;
}

export interface ProductCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nameEn?: Maybe<String>;
  nameEn_not?: Maybe<String>;
  nameEn_in?: Maybe<String[] | String>;
  nameEn_not_in?: Maybe<String[] | String>;
  nameEn_lt?: Maybe<String>;
  nameEn_lte?: Maybe<String>;
  nameEn_gt?: Maybe<String>;
  nameEn_gte?: Maybe<String>;
  nameEn_contains?: Maybe<String>;
  nameEn_not_contains?: Maybe<String>;
  nameEn_starts_with?: Maybe<String>;
  nameEn_not_starts_with?: Maybe<String>;
  nameEn_ends_with?: Maybe<String>;
  nameEn_not_ends_with?: Maybe<String>;
  nameChi?: Maybe<String>;
  nameChi_not?: Maybe<String>;
  nameChi_in?: Maybe<String[] | String>;
  nameChi_not_in?: Maybe<String[] | String>;
  nameChi_lt?: Maybe<String>;
  nameChi_lte?: Maybe<String>;
  nameChi_gt?: Maybe<String>;
  nameChi_gte?: Maybe<String>;
  nameChi_contains?: Maybe<String>;
  nameChi_not_contains?: Maybe<String>;
  nameChi_starts_with?: Maybe<String>;
  nameChi_not_starts_with?: Maybe<String>;
  nameChi_ends_with?: Maybe<String>;
  nameChi_not_ends_with?: Maybe<String>;
  detail?: Maybe<String>;
  detail_not?: Maybe<String>;
  detail_in?: Maybe<String[] | String>;
  detail_not_in?: Maybe<String[] | String>;
  detail_lt?: Maybe<String>;
  detail_lte?: Maybe<String>;
  detail_gt?: Maybe<String>;
  detail_gte?: Maybe<String>;
  detail_contains?: Maybe<String>;
  detail_not_contains?: Maybe<String>;
  detail_starts_with?: Maybe<String>;
  detail_not_starts_with?: Maybe<String>;
  detail_ends_with?: Maybe<String>;
  detail_not_ends_with?: Maybe<String>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductCategoryWhereInput[] | ProductCategoryWhereInput>;
  OR?: Maybe<ProductCategoryWhereInput[] | ProductCategoryWhereInput>;
  NOT?: Maybe<ProductCategoryWhereInput[] | ProductCategoryWhereInput>;
}

export interface ProductImageCreateManyInput {
  create?: Maybe<ProductImageCreateInput[] | ProductImageCreateInput>;
}

export interface ProductCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductCategoryWhereInput>;
  AND?: Maybe<
    | ProductCategorySubscriptionWhereInput[]
    | ProductCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductCategorySubscriptionWhereInput[]
    | ProductCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductCategorySubscriptionWhereInput[]
    | ProductCategorySubscriptionWhereInput
  >;
}

export interface ProductImageCreateInput {
  src: String;
  title: String;
}

export interface ProductImageUpdateManyMutationInput {
  src?: Maybe<String>;
  title?: Maybe<String>;
}

export interface ProductCategoryCreateManyWithoutProductsInput {
  create?: Maybe<
    | ProductCategoryCreateWithoutProductsInput[]
    | ProductCategoryCreateWithoutProductsInput
  >;
  connect?: Maybe<
    ProductCategoryWhereUniqueInput[] | ProductCategoryWhereUniqueInput
  >;
}

export interface ProductUpdateManyDataInput {
  code?: Maybe<String>;
  brandEn?: Maybe<String>;
  brandChi?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  discount?: Maybe<String>;
  package?: Maybe<Int>;
  weight?: Maybe<String>;
  shortDescription?: Maybe<String>;
  longDescription?: Maybe<String>;
  sku?: Maybe<String>;
  upc?: Maybe<String>;
  cost?: Maybe<Float>;
  printInLabel?: Maybe<Boolean>;
  printInInvoice?: Maybe<Boolean>;
  printInDN?: Maybe<Boolean>;
  wholeSalePrice1?: Maybe<Float>;
  wholeSalePrice2?: Maybe<Float>;
  wholeSalePrice3?: Maybe<Float>;
  wholeSalePrice4?: Maybe<Float>;
  wholeSalePrice5?: Maybe<Float>;
  retailPrice1?: Maybe<Float>;
  retailPrice2?: Maybe<Float>;
  retailPrice3?: Maybe<Float>;
  retailPrice4?: Maybe<Float>;
  retailPrice5?: Maybe<Float>;
  minOrderQuantity?: Maybe<Float>;
  minStockLevel?: Maybe<Float>;
  onlineDate?: Maybe<DateTimeInput>;
  offlineDate?: Maybe<DateTimeInput>;
}

export interface ProductCategoryCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  nameEn: String;
  nameChi: String;
  detail?: Maybe<String>;
}

export interface ProductScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  brandEn?: Maybe<String>;
  brandEn_not?: Maybe<String>;
  brandEn_in?: Maybe<String[] | String>;
  brandEn_not_in?: Maybe<String[] | String>;
  brandEn_lt?: Maybe<String>;
  brandEn_lte?: Maybe<String>;
  brandEn_gt?: Maybe<String>;
  brandEn_gte?: Maybe<String>;
  brandEn_contains?: Maybe<String>;
  brandEn_not_contains?: Maybe<String>;
  brandEn_starts_with?: Maybe<String>;
  brandEn_not_starts_with?: Maybe<String>;
  brandEn_ends_with?: Maybe<String>;
  brandEn_not_ends_with?: Maybe<String>;
  brandChi?: Maybe<String>;
  brandChi_not?: Maybe<String>;
  brandChi_in?: Maybe<String[] | String>;
  brandChi_not_in?: Maybe<String[] | String>;
  brandChi_lt?: Maybe<String>;
  brandChi_lte?: Maybe<String>;
  brandChi_gt?: Maybe<String>;
  brandChi_gte?: Maybe<String>;
  brandChi_contains?: Maybe<String>;
  brandChi_not_contains?: Maybe<String>;
  brandChi_starts_with?: Maybe<String>;
  brandChi_not_starts_with?: Maybe<String>;
  brandChi_ends_with?: Maybe<String>;
  brandChi_not_ends_with?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameEn_not?: Maybe<String>;
  nameEn_in?: Maybe<String[] | String>;
  nameEn_not_in?: Maybe<String[] | String>;
  nameEn_lt?: Maybe<String>;
  nameEn_lte?: Maybe<String>;
  nameEn_gt?: Maybe<String>;
  nameEn_gte?: Maybe<String>;
  nameEn_contains?: Maybe<String>;
  nameEn_not_contains?: Maybe<String>;
  nameEn_starts_with?: Maybe<String>;
  nameEn_not_starts_with?: Maybe<String>;
  nameEn_ends_with?: Maybe<String>;
  nameEn_not_ends_with?: Maybe<String>;
  nameChi?: Maybe<String>;
  nameChi_not?: Maybe<String>;
  nameChi_in?: Maybe<String[] | String>;
  nameChi_not_in?: Maybe<String[] | String>;
  nameChi_lt?: Maybe<String>;
  nameChi_lte?: Maybe<String>;
  nameChi_gt?: Maybe<String>;
  nameChi_gte?: Maybe<String>;
  nameChi_contains?: Maybe<String>;
  nameChi_not_contains?: Maybe<String>;
  nameChi_starts_with?: Maybe<String>;
  nameChi_not_starts_with?: Maybe<String>;
  nameChi_ends_with?: Maybe<String>;
  nameChi_not_ends_with?: Maybe<String>;
  discount?: Maybe<String>;
  discount_not?: Maybe<String>;
  discount_in?: Maybe<String[] | String>;
  discount_not_in?: Maybe<String[] | String>;
  discount_lt?: Maybe<String>;
  discount_lte?: Maybe<String>;
  discount_gt?: Maybe<String>;
  discount_gte?: Maybe<String>;
  discount_contains?: Maybe<String>;
  discount_not_contains?: Maybe<String>;
  discount_starts_with?: Maybe<String>;
  discount_not_starts_with?: Maybe<String>;
  discount_ends_with?: Maybe<String>;
  discount_not_ends_with?: Maybe<String>;
  package?: Maybe<Int>;
  package_not?: Maybe<Int>;
  package_in?: Maybe<Int[] | Int>;
  package_not_in?: Maybe<Int[] | Int>;
  package_lt?: Maybe<Int>;
  package_lte?: Maybe<Int>;
  package_gt?: Maybe<Int>;
  package_gte?: Maybe<Int>;
  weight?: Maybe<String>;
  weight_not?: Maybe<String>;
  weight_in?: Maybe<String[] | String>;
  weight_not_in?: Maybe<String[] | String>;
  weight_lt?: Maybe<String>;
  weight_lte?: Maybe<String>;
  weight_gt?: Maybe<String>;
  weight_gte?: Maybe<String>;
  weight_contains?: Maybe<String>;
  weight_not_contains?: Maybe<String>;
  weight_starts_with?: Maybe<String>;
  weight_not_starts_with?: Maybe<String>;
  weight_ends_with?: Maybe<String>;
  weight_not_ends_with?: Maybe<String>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  longDescription?: Maybe<String>;
  longDescription_not?: Maybe<String>;
  longDescription_in?: Maybe<String[] | String>;
  longDescription_not_in?: Maybe<String[] | String>;
  longDescription_lt?: Maybe<String>;
  longDescription_lte?: Maybe<String>;
  longDescription_gt?: Maybe<String>;
  longDescription_gte?: Maybe<String>;
  longDescription_contains?: Maybe<String>;
  longDescription_not_contains?: Maybe<String>;
  longDescription_starts_with?: Maybe<String>;
  longDescription_not_starts_with?: Maybe<String>;
  longDescription_ends_with?: Maybe<String>;
  longDescription_not_ends_with?: Maybe<String>;
  sku?: Maybe<String>;
  sku_not?: Maybe<String>;
  sku_in?: Maybe<String[] | String>;
  sku_not_in?: Maybe<String[] | String>;
  sku_lt?: Maybe<String>;
  sku_lte?: Maybe<String>;
  sku_gt?: Maybe<String>;
  sku_gte?: Maybe<String>;
  sku_contains?: Maybe<String>;
  sku_not_contains?: Maybe<String>;
  sku_starts_with?: Maybe<String>;
  sku_not_starts_with?: Maybe<String>;
  sku_ends_with?: Maybe<String>;
  sku_not_ends_with?: Maybe<String>;
  upc?: Maybe<String>;
  upc_not?: Maybe<String>;
  upc_in?: Maybe<String[] | String>;
  upc_not_in?: Maybe<String[] | String>;
  upc_lt?: Maybe<String>;
  upc_lte?: Maybe<String>;
  upc_gt?: Maybe<String>;
  upc_gte?: Maybe<String>;
  upc_contains?: Maybe<String>;
  upc_not_contains?: Maybe<String>;
  upc_starts_with?: Maybe<String>;
  upc_not_starts_with?: Maybe<String>;
  upc_ends_with?: Maybe<String>;
  upc_not_ends_with?: Maybe<String>;
  cost?: Maybe<Float>;
  cost_not?: Maybe<Float>;
  cost_in?: Maybe<Float[] | Float>;
  cost_not_in?: Maybe<Float[] | Float>;
  cost_lt?: Maybe<Float>;
  cost_lte?: Maybe<Float>;
  cost_gt?: Maybe<Float>;
  cost_gte?: Maybe<Float>;
  printInLabel?: Maybe<Boolean>;
  printInLabel_not?: Maybe<Boolean>;
  printInInvoice?: Maybe<Boolean>;
  printInInvoice_not?: Maybe<Boolean>;
  printInDN?: Maybe<Boolean>;
  printInDN_not?: Maybe<Boolean>;
  wholeSalePrice1?: Maybe<Float>;
  wholeSalePrice1_not?: Maybe<Float>;
  wholeSalePrice1_in?: Maybe<Float[] | Float>;
  wholeSalePrice1_not_in?: Maybe<Float[] | Float>;
  wholeSalePrice1_lt?: Maybe<Float>;
  wholeSalePrice1_lte?: Maybe<Float>;
  wholeSalePrice1_gt?: Maybe<Float>;
  wholeSalePrice1_gte?: Maybe<Float>;
  wholeSalePrice2?: Maybe<Float>;
  wholeSalePrice2_not?: Maybe<Float>;
  wholeSalePrice2_in?: Maybe<Float[] | Float>;
  wholeSalePrice2_not_in?: Maybe<Float[] | Float>;
  wholeSalePrice2_lt?: Maybe<Float>;
  wholeSalePrice2_lte?: Maybe<Float>;
  wholeSalePrice2_gt?: Maybe<Float>;
  wholeSalePrice2_gte?: Maybe<Float>;
  wholeSalePrice3?: Maybe<Float>;
  wholeSalePrice3_not?: Maybe<Float>;
  wholeSalePrice3_in?: Maybe<Float[] | Float>;
  wholeSalePrice3_not_in?: Maybe<Float[] | Float>;
  wholeSalePrice3_lt?: Maybe<Float>;
  wholeSalePrice3_lte?: Maybe<Float>;
  wholeSalePrice3_gt?: Maybe<Float>;
  wholeSalePrice3_gte?: Maybe<Float>;
  wholeSalePrice4?: Maybe<Float>;
  wholeSalePrice4_not?: Maybe<Float>;
  wholeSalePrice4_in?: Maybe<Float[] | Float>;
  wholeSalePrice4_not_in?: Maybe<Float[] | Float>;
  wholeSalePrice4_lt?: Maybe<Float>;
  wholeSalePrice4_lte?: Maybe<Float>;
  wholeSalePrice4_gt?: Maybe<Float>;
  wholeSalePrice4_gte?: Maybe<Float>;
  wholeSalePrice5?: Maybe<Float>;
  wholeSalePrice5_not?: Maybe<Float>;
  wholeSalePrice5_in?: Maybe<Float[] | Float>;
  wholeSalePrice5_not_in?: Maybe<Float[] | Float>;
  wholeSalePrice5_lt?: Maybe<Float>;
  wholeSalePrice5_lte?: Maybe<Float>;
  wholeSalePrice5_gt?: Maybe<Float>;
  wholeSalePrice5_gte?: Maybe<Float>;
  retailPrice1?: Maybe<Float>;
  retailPrice1_not?: Maybe<Float>;
  retailPrice1_in?: Maybe<Float[] | Float>;
  retailPrice1_not_in?: Maybe<Float[] | Float>;
  retailPrice1_lt?: Maybe<Float>;
  retailPrice1_lte?: Maybe<Float>;
  retailPrice1_gt?: Maybe<Float>;
  retailPrice1_gte?: Maybe<Float>;
  retailPrice2?: Maybe<Float>;
  retailPrice2_not?: Maybe<Float>;
  retailPrice2_in?: Maybe<Float[] | Float>;
  retailPrice2_not_in?: Maybe<Float[] | Float>;
  retailPrice2_lt?: Maybe<Float>;
  retailPrice2_lte?: Maybe<Float>;
  retailPrice2_gt?: Maybe<Float>;
  retailPrice2_gte?: Maybe<Float>;
  retailPrice3?: Maybe<Float>;
  retailPrice3_not?: Maybe<Float>;
  retailPrice3_in?: Maybe<Float[] | Float>;
  retailPrice3_not_in?: Maybe<Float[] | Float>;
  retailPrice3_lt?: Maybe<Float>;
  retailPrice3_lte?: Maybe<Float>;
  retailPrice3_gt?: Maybe<Float>;
  retailPrice3_gte?: Maybe<Float>;
  retailPrice4?: Maybe<Float>;
  retailPrice4_not?: Maybe<Float>;
  retailPrice4_in?: Maybe<Float[] | Float>;
  retailPrice4_not_in?: Maybe<Float[] | Float>;
  retailPrice4_lt?: Maybe<Float>;
  retailPrice4_lte?: Maybe<Float>;
  retailPrice4_gt?: Maybe<Float>;
  retailPrice4_gte?: Maybe<Float>;
  retailPrice5?: Maybe<Float>;
  retailPrice5_not?: Maybe<Float>;
  retailPrice5_in?: Maybe<Float[] | Float>;
  retailPrice5_not_in?: Maybe<Float[] | Float>;
  retailPrice5_lt?: Maybe<Float>;
  retailPrice5_lte?: Maybe<Float>;
  retailPrice5_gt?: Maybe<Float>;
  retailPrice5_gte?: Maybe<Float>;
  minOrderQuantity?: Maybe<Float>;
  minOrderQuantity_not?: Maybe<Float>;
  minOrderQuantity_in?: Maybe<Float[] | Float>;
  minOrderQuantity_not_in?: Maybe<Float[] | Float>;
  minOrderQuantity_lt?: Maybe<Float>;
  minOrderQuantity_lte?: Maybe<Float>;
  minOrderQuantity_gt?: Maybe<Float>;
  minOrderQuantity_gte?: Maybe<Float>;
  minStockLevel?: Maybe<Float>;
  minStockLevel_not?: Maybe<Float>;
  minStockLevel_in?: Maybe<Float[] | Float>;
  minStockLevel_not_in?: Maybe<Float[] | Float>;
  minStockLevel_lt?: Maybe<Float>;
  minStockLevel_lte?: Maybe<Float>;
  minStockLevel_gt?: Maybe<Float>;
  minStockLevel_gte?: Maybe<Float>;
  onlineDate?: Maybe<DateTimeInput>;
  onlineDate_not?: Maybe<DateTimeInput>;
  onlineDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  onlineDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  onlineDate_lt?: Maybe<DateTimeInput>;
  onlineDate_lte?: Maybe<DateTimeInput>;
  onlineDate_gt?: Maybe<DateTimeInput>;
  onlineDate_gte?: Maybe<DateTimeInput>;
  offlineDate?: Maybe<DateTimeInput>;
  offlineDate_not?: Maybe<DateTimeInput>;
  offlineDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  offlineDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  offlineDate_lt?: Maybe<DateTimeInput>;
  offlineDate_lte?: Maybe<DateTimeInput>;
  offlineDate_gt?: Maybe<DateTimeInput>;
  offlineDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  OR?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  NOT?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
}

export interface ProductUpdateInput {
  code?: Maybe<String>;
  brandEn?: Maybe<String>;
  brandChi?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  discount?: Maybe<String>;
  package?: Maybe<Int>;
  weight?: Maybe<String>;
  shortDescription?: Maybe<String>;
  longDescription?: Maybe<String>;
  images?: Maybe<ProductImageUpdateManyInput>;
  sku?: Maybe<String>;
  upc?: Maybe<String>;
  cost?: Maybe<Float>;
  printInLabel?: Maybe<Boolean>;
  printInInvoice?: Maybe<Boolean>;
  printInDN?: Maybe<Boolean>;
  wholeSalePrice1?: Maybe<Float>;
  wholeSalePrice2?: Maybe<Float>;
  wholeSalePrice3?: Maybe<Float>;
  wholeSalePrice4?: Maybe<Float>;
  wholeSalePrice5?: Maybe<Float>;
  retailPrice1?: Maybe<Float>;
  retailPrice2?: Maybe<Float>;
  retailPrice3?: Maybe<Float>;
  retailPrice4?: Maybe<Float>;
  retailPrice5?: Maybe<Float>;
  minOrderQuantity?: Maybe<Float>;
  minStockLevel?: Maybe<Float>;
  onlineDate?: Maybe<DateTimeInput>;
  offlineDate?: Maybe<DateTimeInput>;
  categories?: Maybe<ProductCategoryUpdateManyWithoutProductsInput>;
}

export interface ProductUpsertWithWhereUniqueWithoutCategoriesInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutCategoriesDataInput;
  create: ProductCreateWithoutCategoriesInput;
}

export interface ProductImageUpdateManyInput {
  create?: Maybe<ProductImageCreateInput[] | ProductImageCreateInput>;
  deleteMany?: Maybe<
    ProductImageScalarWhereInput[] | ProductImageScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductImageUpdateManyWithWhereNestedInput[]
    | ProductImageUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateWithWhereUniqueWithoutCategoriesInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutCategoriesDataInput;
}

export interface ProductCreateManyWithoutCategoriesInput {
  create?: Maybe<
    ProductCreateWithoutCategoriesInput[] | ProductCreateWithoutCategoriesInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface ProductCategoryUpdateInput {
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  detail?: Maybe<String>;
  products?: Maybe<ProductUpdateManyWithoutCategoriesInput>;
}

export interface ProductImageUpdateManyWithWhereNestedInput {
  where: ProductImageScalarWhereInput;
  data: ProductImageUpdateManyDataInput;
}

export interface ProductImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductImageWhereInput>;
  AND?: Maybe<
    ProductImageSubscriptionWhereInput[] | ProductImageSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProductImageSubscriptionWhereInput[] | ProductImageSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProductImageSubscriptionWhereInput[] | ProductImageSubscriptionWhereInput
  >;
}

export interface ProductImageUpdateManyDataInput {
  src?: Maybe<String>;
  title?: Maybe<String>;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface ProductCategoryCreateInput {
  id?: Maybe<ID_Input>;
  nameEn: String;
  nameChi: String;
  detail?: Maybe<String>;
  products?: Maybe<ProductCreateManyWithoutCategoriesInput>;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface ProductUpdateManyMutationInput {
  code?: Maybe<String>;
  brandEn?: Maybe<String>;
  brandChi?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  discount?: Maybe<String>;
  package?: Maybe<Int>;
  weight?: Maybe<String>;
  shortDescription?: Maybe<String>;
  longDescription?: Maybe<String>;
  sku?: Maybe<String>;
  upc?: Maybe<String>;
  cost?: Maybe<Float>;
  printInLabel?: Maybe<Boolean>;
  printInInvoice?: Maybe<Boolean>;
  printInDN?: Maybe<Boolean>;
  wholeSalePrice1?: Maybe<Float>;
  wholeSalePrice2?: Maybe<Float>;
  wholeSalePrice3?: Maybe<Float>;
  wholeSalePrice4?: Maybe<Float>;
  wholeSalePrice5?: Maybe<Float>;
  retailPrice1?: Maybe<Float>;
  retailPrice2?: Maybe<Float>;
  retailPrice3?: Maybe<Float>;
  retailPrice4?: Maybe<Float>;
  retailPrice5?: Maybe<Float>;
  minOrderQuantity?: Maybe<Float>;
  minStockLevel?: Maybe<Float>;
  onlineDate?: Maybe<DateTimeInput>;
  offlineDate?: Maybe<DateTimeInput>;
}

export interface ProductUpdateWithoutCategoriesDataInput {
  code?: Maybe<String>;
  brandEn?: Maybe<String>;
  brandChi?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  discount?: Maybe<String>;
  package?: Maybe<Int>;
  weight?: Maybe<String>;
  shortDescription?: Maybe<String>;
  longDescription?: Maybe<String>;
  images?: Maybe<ProductImageUpdateManyInput>;
  sku?: Maybe<String>;
  upc?: Maybe<String>;
  cost?: Maybe<Float>;
  printInLabel?: Maybe<Boolean>;
  printInInvoice?: Maybe<Boolean>;
  printInDN?: Maybe<Boolean>;
  wholeSalePrice1?: Maybe<Float>;
  wholeSalePrice2?: Maybe<Float>;
  wholeSalePrice3?: Maybe<Float>;
  wholeSalePrice4?: Maybe<Float>;
  wholeSalePrice5?: Maybe<Float>;
  retailPrice1?: Maybe<Float>;
  retailPrice2?: Maybe<Float>;
  retailPrice3?: Maybe<Float>;
  retailPrice4?: Maybe<Float>;
  retailPrice5?: Maybe<Float>;
  minOrderQuantity?: Maybe<Float>;
  minStockLevel?: Maybe<Float>;
  onlineDate?: Maybe<DateTimeInput>;
  offlineDate?: Maybe<DateTimeInput>;
}

export interface ProductCategoryUpdateManyWithWhereNestedInput {
  where: ProductCategoryScalarWhereInput;
  data: ProductCategoryUpdateManyDataInput;
}

export interface ProductCategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nameEn?: Maybe<String>;
  nameEn_not?: Maybe<String>;
  nameEn_in?: Maybe<String[] | String>;
  nameEn_not_in?: Maybe<String[] | String>;
  nameEn_lt?: Maybe<String>;
  nameEn_lte?: Maybe<String>;
  nameEn_gt?: Maybe<String>;
  nameEn_gte?: Maybe<String>;
  nameEn_contains?: Maybe<String>;
  nameEn_not_contains?: Maybe<String>;
  nameEn_starts_with?: Maybe<String>;
  nameEn_not_starts_with?: Maybe<String>;
  nameEn_ends_with?: Maybe<String>;
  nameEn_not_ends_with?: Maybe<String>;
  nameChi?: Maybe<String>;
  nameChi_not?: Maybe<String>;
  nameChi_in?: Maybe<String[] | String>;
  nameChi_not_in?: Maybe<String[] | String>;
  nameChi_lt?: Maybe<String>;
  nameChi_lte?: Maybe<String>;
  nameChi_gt?: Maybe<String>;
  nameChi_gte?: Maybe<String>;
  nameChi_contains?: Maybe<String>;
  nameChi_not_contains?: Maybe<String>;
  nameChi_starts_with?: Maybe<String>;
  nameChi_not_starts_with?: Maybe<String>;
  nameChi_ends_with?: Maybe<String>;
  nameChi_not_ends_with?: Maybe<String>;
  detail?: Maybe<String>;
  detail_not?: Maybe<String>;
  detail_in?: Maybe<String[] | String>;
  detail_not_in?: Maybe<String[] | String>;
  detail_lt?: Maybe<String>;
  detail_lte?: Maybe<String>;
  detail_gt?: Maybe<String>;
  detail_gte?: Maybe<String>;
  detail_contains?: Maybe<String>;
  detail_not_contains?: Maybe<String>;
  detail_starts_with?: Maybe<String>;
  detail_not_starts_with?: Maybe<String>;
  detail_ends_with?: Maybe<String>;
  detail_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ProductCategoryScalarWhereInput[] | ProductCategoryScalarWhereInput
  >;
  OR?: Maybe<
    ProductCategoryScalarWhereInput[] | ProductCategoryScalarWhereInput
  >;
  NOT?: Maybe<
    ProductCategoryScalarWhereInput[] | ProductCategoryScalarWhereInput
  >;
}

export interface ProductCategoryUpsertWithWhereUniqueWithoutProductsInput {
  where: ProductCategoryWhereUniqueInput;
  update: ProductCategoryUpdateWithoutProductsDataInput;
  create: ProductCategoryCreateWithoutProductsInput;
}

export interface ProductCategoryUpdateWithoutProductsDataInput {
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  detail?: Maybe<String>;
}

export interface ProductUpdateManyWithoutCategoriesInput {
  create?: Maybe<
    ProductCreateWithoutCategoriesInput[] | ProductCreateWithoutCategoriesInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutCategoriesInput[]
    | ProductUpdateWithWhereUniqueWithoutCategoriesInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutCategoriesInput[]
    | ProductUpsertWithWhereUniqueWithoutCategoriesInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export type ProductCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
}>;

export interface ProductCategoryUpdateManyMutationInput {
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  detail?: Maybe<String>;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  brandEn?: Maybe<String>;
  brandEn_not?: Maybe<String>;
  brandEn_in?: Maybe<String[] | String>;
  brandEn_not_in?: Maybe<String[] | String>;
  brandEn_lt?: Maybe<String>;
  brandEn_lte?: Maybe<String>;
  brandEn_gt?: Maybe<String>;
  brandEn_gte?: Maybe<String>;
  brandEn_contains?: Maybe<String>;
  brandEn_not_contains?: Maybe<String>;
  brandEn_starts_with?: Maybe<String>;
  brandEn_not_starts_with?: Maybe<String>;
  brandEn_ends_with?: Maybe<String>;
  brandEn_not_ends_with?: Maybe<String>;
  brandChi?: Maybe<String>;
  brandChi_not?: Maybe<String>;
  brandChi_in?: Maybe<String[] | String>;
  brandChi_not_in?: Maybe<String[] | String>;
  brandChi_lt?: Maybe<String>;
  brandChi_lte?: Maybe<String>;
  brandChi_gt?: Maybe<String>;
  brandChi_gte?: Maybe<String>;
  brandChi_contains?: Maybe<String>;
  brandChi_not_contains?: Maybe<String>;
  brandChi_starts_with?: Maybe<String>;
  brandChi_not_starts_with?: Maybe<String>;
  brandChi_ends_with?: Maybe<String>;
  brandChi_not_ends_with?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameEn_not?: Maybe<String>;
  nameEn_in?: Maybe<String[] | String>;
  nameEn_not_in?: Maybe<String[] | String>;
  nameEn_lt?: Maybe<String>;
  nameEn_lte?: Maybe<String>;
  nameEn_gt?: Maybe<String>;
  nameEn_gte?: Maybe<String>;
  nameEn_contains?: Maybe<String>;
  nameEn_not_contains?: Maybe<String>;
  nameEn_starts_with?: Maybe<String>;
  nameEn_not_starts_with?: Maybe<String>;
  nameEn_ends_with?: Maybe<String>;
  nameEn_not_ends_with?: Maybe<String>;
  nameChi?: Maybe<String>;
  nameChi_not?: Maybe<String>;
  nameChi_in?: Maybe<String[] | String>;
  nameChi_not_in?: Maybe<String[] | String>;
  nameChi_lt?: Maybe<String>;
  nameChi_lte?: Maybe<String>;
  nameChi_gt?: Maybe<String>;
  nameChi_gte?: Maybe<String>;
  nameChi_contains?: Maybe<String>;
  nameChi_not_contains?: Maybe<String>;
  nameChi_starts_with?: Maybe<String>;
  nameChi_not_starts_with?: Maybe<String>;
  nameChi_ends_with?: Maybe<String>;
  nameChi_not_ends_with?: Maybe<String>;
  discount?: Maybe<String>;
  discount_not?: Maybe<String>;
  discount_in?: Maybe<String[] | String>;
  discount_not_in?: Maybe<String[] | String>;
  discount_lt?: Maybe<String>;
  discount_lte?: Maybe<String>;
  discount_gt?: Maybe<String>;
  discount_gte?: Maybe<String>;
  discount_contains?: Maybe<String>;
  discount_not_contains?: Maybe<String>;
  discount_starts_with?: Maybe<String>;
  discount_not_starts_with?: Maybe<String>;
  discount_ends_with?: Maybe<String>;
  discount_not_ends_with?: Maybe<String>;
  package?: Maybe<Int>;
  package_not?: Maybe<Int>;
  package_in?: Maybe<Int[] | Int>;
  package_not_in?: Maybe<Int[] | Int>;
  package_lt?: Maybe<Int>;
  package_lte?: Maybe<Int>;
  package_gt?: Maybe<Int>;
  package_gte?: Maybe<Int>;
  weight?: Maybe<String>;
  weight_not?: Maybe<String>;
  weight_in?: Maybe<String[] | String>;
  weight_not_in?: Maybe<String[] | String>;
  weight_lt?: Maybe<String>;
  weight_lte?: Maybe<String>;
  weight_gt?: Maybe<String>;
  weight_gte?: Maybe<String>;
  weight_contains?: Maybe<String>;
  weight_not_contains?: Maybe<String>;
  weight_starts_with?: Maybe<String>;
  weight_not_starts_with?: Maybe<String>;
  weight_ends_with?: Maybe<String>;
  weight_not_ends_with?: Maybe<String>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  longDescription?: Maybe<String>;
  longDescription_not?: Maybe<String>;
  longDescription_in?: Maybe<String[] | String>;
  longDescription_not_in?: Maybe<String[] | String>;
  longDescription_lt?: Maybe<String>;
  longDescription_lte?: Maybe<String>;
  longDescription_gt?: Maybe<String>;
  longDescription_gte?: Maybe<String>;
  longDescription_contains?: Maybe<String>;
  longDescription_not_contains?: Maybe<String>;
  longDescription_starts_with?: Maybe<String>;
  longDescription_not_starts_with?: Maybe<String>;
  longDescription_ends_with?: Maybe<String>;
  longDescription_not_ends_with?: Maybe<String>;
  images_every?: Maybe<ProductImageWhereInput>;
  images_some?: Maybe<ProductImageWhereInput>;
  images_none?: Maybe<ProductImageWhereInput>;
  sku?: Maybe<String>;
  sku_not?: Maybe<String>;
  sku_in?: Maybe<String[] | String>;
  sku_not_in?: Maybe<String[] | String>;
  sku_lt?: Maybe<String>;
  sku_lte?: Maybe<String>;
  sku_gt?: Maybe<String>;
  sku_gte?: Maybe<String>;
  sku_contains?: Maybe<String>;
  sku_not_contains?: Maybe<String>;
  sku_starts_with?: Maybe<String>;
  sku_not_starts_with?: Maybe<String>;
  sku_ends_with?: Maybe<String>;
  sku_not_ends_with?: Maybe<String>;
  upc?: Maybe<String>;
  upc_not?: Maybe<String>;
  upc_in?: Maybe<String[] | String>;
  upc_not_in?: Maybe<String[] | String>;
  upc_lt?: Maybe<String>;
  upc_lte?: Maybe<String>;
  upc_gt?: Maybe<String>;
  upc_gte?: Maybe<String>;
  upc_contains?: Maybe<String>;
  upc_not_contains?: Maybe<String>;
  upc_starts_with?: Maybe<String>;
  upc_not_starts_with?: Maybe<String>;
  upc_ends_with?: Maybe<String>;
  upc_not_ends_with?: Maybe<String>;
  cost?: Maybe<Float>;
  cost_not?: Maybe<Float>;
  cost_in?: Maybe<Float[] | Float>;
  cost_not_in?: Maybe<Float[] | Float>;
  cost_lt?: Maybe<Float>;
  cost_lte?: Maybe<Float>;
  cost_gt?: Maybe<Float>;
  cost_gte?: Maybe<Float>;
  printInLabel?: Maybe<Boolean>;
  printInLabel_not?: Maybe<Boolean>;
  printInInvoice?: Maybe<Boolean>;
  printInInvoice_not?: Maybe<Boolean>;
  printInDN?: Maybe<Boolean>;
  printInDN_not?: Maybe<Boolean>;
  wholeSalePrice1?: Maybe<Float>;
  wholeSalePrice1_not?: Maybe<Float>;
  wholeSalePrice1_in?: Maybe<Float[] | Float>;
  wholeSalePrice1_not_in?: Maybe<Float[] | Float>;
  wholeSalePrice1_lt?: Maybe<Float>;
  wholeSalePrice1_lte?: Maybe<Float>;
  wholeSalePrice1_gt?: Maybe<Float>;
  wholeSalePrice1_gte?: Maybe<Float>;
  wholeSalePrice2?: Maybe<Float>;
  wholeSalePrice2_not?: Maybe<Float>;
  wholeSalePrice2_in?: Maybe<Float[] | Float>;
  wholeSalePrice2_not_in?: Maybe<Float[] | Float>;
  wholeSalePrice2_lt?: Maybe<Float>;
  wholeSalePrice2_lte?: Maybe<Float>;
  wholeSalePrice2_gt?: Maybe<Float>;
  wholeSalePrice2_gte?: Maybe<Float>;
  wholeSalePrice3?: Maybe<Float>;
  wholeSalePrice3_not?: Maybe<Float>;
  wholeSalePrice3_in?: Maybe<Float[] | Float>;
  wholeSalePrice3_not_in?: Maybe<Float[] | Float>;
  wholeSalePrice3_lt?: Maybe<Float>;
  wholeSalePrice3_lte?: Maybe<Float>;
  wholeSalePrice3_gt?: Maybe<Float>;
  wholeSalePrice3_gte?: Maybe<Float>;
  wholeSalePrice4?: Maybe<Float>;
  wholeSalePrice4_not?: Maybe<Float>;
  wholeSalePrice4_in?: Maybe<Float[] | Float>;
  wholeSalePrice4_not_in?: Maybe<Float[] | Float>;
  wholeSalePrice4_lt?: Maybe<Float>;
  wholeSalePrice4_lte?: Maybe<Float>;
  wholeSalePrice4_gt?: Maybe<Float>;
  wholeSalePrice4_gte?: Maybe<Float>;
  wholeSalePrice5?: Maybe<Float>;
  wholeSalePrice5_not?: Maybe<Float>;
  wholeSalePrice5_in?: Maybe<Float[] | Float>;
  wholeSalePrice5_not_in?: Maybe<Float[] | Float>;
  wholeSalePrice5_lt?: Maybe<Float>;
  wholeSalePrice5_lte?: Maybe<Float>;
  wholeSalePrice5_gt?: Maybe<Float>;
  wholeSalePrice5_gte?: Maybe<Float>;
  retailPrice1?: Maybe<Float>;
  retailPrice1_not?: Maybe<Float>;
  retailPrice1_in?: Maybe<Float[] | Float>;
  retailPrice1_not_in?: Maybe<Float[] | Float>;
  retailPrice1_lt?: Maybe<Float>;
  retailPrice1_lte?: Maybe<Float>;
  retailPrice1_gt?: Maybe<Float>;
  retailPrice1_gte?: Maybe<Float>;
  retailPrice2?: Maybe<Float>;
  retailPrice2_not?: Maybe<Float>;
  retailPrice2_in?: Maybe<Float[] | Float>;
  retailPrice2_not_in?: Maybe<Float[] | Float>;
  retailPrice2_lt?: Maybe<Float>;
  retailPrice2_lte?: Maybe<Float>;
  retailPrice2_gt?: Maybe<Float>;
  retailPrice2_gte?: Maybe<Float>;
  retailPrice3?: Maybe<Float>;
  retailPrice3_not?: Maybe<Float>;
  retailPrice3_in?: Maybe<Float[] | Float>;
  retailPrice3_not_in?: Maybe<Float[] | Float>;
  retailPrice3_lt?: Maybe<Float>;
  retailPrice3_lte?: Maybe<Float>;
  retailPrice3_gt?: Maybe<Float>;
  retailPrice3_gte?: Maybe<Float>;
  retailPrice4?: Maybe<Float>;
  retailPrice4_not?: Maybe<Float>;
  retailPrice4_in?: Maybe<Float[] | Float>;
  retailPrice4_not_in?: Maybe<Float[] | Float>;
  retailPrice4_lt?: Maybe<Float>;
  retailPrice4_lte?: Maybe<Float>;
  retailPrice4_gt?: Maybe<Float>;
  retailPrice4_gte?: Maybe<Float>;
  retailPrice5?: Maybe<Float>;
  retailPrice5_not?: Maybe<Float>;
  retailPrice5_in?: Maybe<Float[] | Float>;
  retailPrice5_not_in?: Maybe<Float[] | Float>;
  retailPrice5_lt?: Maybe<Float>;
  retailPrice5_lte?: Maybe<Float>;
  retailPrice5_gt?: Maybe<Float>;
  retailPrice5_gte?: Maybe<Float>;
  minOrderQuantity?: Maybe<Float>;
  minOrderQuantity_not?: Maybe<Float>;
  minOrderQuantity_in?: Maybe<Float[] | Float>;
  minOrderQuantity_not_in?: Maybe<Float[] | Float>;
  minOrderQuantity_lt?: Maybe<Float>;
  minOrderQuantity_lte?: Maybe<Float>;
  minOrderQuantity_gt?: Maybe<Float>;
  minOrderQuantity_gte?: Maybe<Float>;
  minStockLevel?: Maybe<Float>;
  minStockLevel_not?: Maybe<Float>;
  minStockLevel_in?: Maybe<Float[] | Float>;
  minStockLevel_not_in?: Maybe<Float[] | Float>;
  minStockLevel_lt?: Maybe<Float>;
  minStockLevel_lte?: Maybe<Float>;
  minStockLevel_gt?: Maybe<Float>;
  minStockLevel_gte?: Maybe<Float>;
  onlineDate?: Maybe<DateTimeInput>;
  onlineDate_not?: Maybe<DateTimeInput>;
  onlineDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  onlineDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  onlineDate_lt?: Maybe<DateTimeInput>;
  onlineDate_lte?: Maybe<DateTimeInput>;
  onlineDate_gt?: Maybe<DateTimeInput>;
  onlineDate_gte?: Maybe<DateTimeInput>;
  offlineDate?: Maybe<DateTimeInput>;
  offlineDate_not?: Maybe<DateTimeInput>;
  offlineDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  offlineDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  offlineDate_lt?: Maybe<DateTimeInput>;
  offlineDate_lte?: Maybe<DateTimeInput>;
  offlineDate_gt?: Maybe<DateTimeInput>;
  offlineDate_gte?: Maybe<DateTimeInput>;
  categories_every?: Maybe<ProductCategoryWhereInput>;
  categories_some?: Maybe<ProductCategoryWhereInput>;
  categories_none?: Maybe<ProductCategoryWhereInput>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface ProductCreateWithoutCategoriesInput {
  id?: Maybe<ID_Input>;
  code: String;
  brandEn: String;
  brandChi: String;
  nameEn: String;
  nameChi: String;
  discount?: Maybe<String>;
  package: Int;
  weight: String;
  shortDescription?: Maybe<String>;
  longDescription?: Maybe<String>;
  images?: Maybe<ProductImageCreateManyInput>;
  sku?: Maybe<String>;
  upc: String;
  cost: Float;
  printInLabel?: Maybe<Boolean>;
  printInInvoice?: Maybe<Boolean>;
  printInDN?: Maybe<Boolean>;
  wholeSalePrice1: Float;
  wholeSalePrice2: Float;
  wholeSalePrice3: Float;
  wholeSalePrice4: Float;
  wholeSalePrice5: Float;
  retailPrice1: Float;
  retailPrice2: Float;
  retailPrice3: Float;
  retailPrice4: Float;
  retailPrice5: Float;
  minOrderQuantity?: Maybe<Float>;
  minStockLevel?: Maybe<Float>;
  onlineDate?: Maybe<DateTimeInput>;
  offlineDate?: Maybe<DateTimeInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ProductImagePreviousValues {
  src: String;
  title: String;
}

export interface ProductImagePreviousValuesPromise
  extends Promise<ProductImagePreviousValues>,
    Fragmentable {
  src: () => Promise<String>;
  title: () => Promise<String>;
}

export interface ProductImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ProductImagePreviousValues>>,
    Fragmentable {
  src: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface ProductCategoryConnection {
  pageInfo: PageInfo;
  edges: ProductCategoryEdge[];
}

export interface ProductCategoryConnectionPromise
  extends Promise<ProductCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductCategoryEdge>>() => T;
  aggregate: <T = AggregateProductCategoryPromise>() => T;
}

export interface ProductCategoryConnectionSubscription
  extends Promise<AsyncIterator<ProductCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductCategorySubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  code: String;
  brandEn: String;
  brandChi: String;
  nameEn: String;
  nameChi: String;
  discount?: String;
  package: Int;
  weight: String;
  shortDescription?: String;
  longDescription?: String;
  sku?: String;
  upc: String;
  cost: Float;
  printInLabel?: Boolean;
  printInInvoice?: Boolean;
  printInDN?: Boolean;
  wholeSalePrice1: Float;
  wholeSalePrice2: Float;
  wholeSalePrice3: Float;
  wholeSalePrice4: Float;
  wholeSalePrice5: Float;
  retailPrice1: Float;
  retailPrice2: Float;
  retailPrice3: Float;
  retailPrice4: Float;
  retailPrice5: Float;
  minOrderQuantity: Float;
  minStockLevel: Float;
  onlineDate?: DateTimeOutput;
  offlineDate?: DateTimeOutput;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  brandEn: () => Promise<String>;
  brandChi: () => Promise<String>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  discount: () => Promise<String>;
  package: () => Promise<Int>;
  weight: () => Promise<String>;
  shortDescription: () => Promise<String>;
  longDescription: () => Promise<String>;
  sku: () => Promise<String>;
  upc: () => Promise<String>;
  cost: () => Promise<Float>;
  printInLabel: () => Promise<Boolean>;
  printInInvoice: () => Promise<Boolean>;
  printInDN: () => Promise<Boolean>;
  wholeSalePrice1: () => Promise<Float>;
  wholeSalePrice2: () => Promise<Float>;
  wholeSalePrice3: () => Promise<Float>;
  wholeSalePrice4: () => Promise<Float>;
  wholeSalePrice5: () => Promise<Float>;
  retailPrice1: () => Promise<Float>;
  retailPrice2: () => Promise<Float>;
  retailPrice3: () => Promise<Float>;
  retailPrice4: () => Promise<Float>;
  retailPrice5: () => Promise<Float>;
  minOrderQuantity: () => Promise<Float>;
  minStockLevel: () => Promise<Float>;
  onlineDate: () => Promise<DateTimeOutput>;
  offlineDate: () => Promise<DateTimeOutput>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  brandEn: () => Promise<AsyncIterator<String>>;
  brandChi: () => Promise<AsyncIterator<String>>;
  nameEn: () => Promise<AsyncIterator<String>>;
  nameChi: () => Promise<AsyncIterator<String>>;
  discount: () => Promise<AsyncIterator<String>>;
  package: () => Promise<AsyncIterator<Int>>;
  weight: () => Promise<AsyncIterator<String>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  longDescription: () => Promise<AsyncIterator<String>>;
  sku: () => Promise<AsyncIterator<String>>;
  upc: () => Promise<AsyncIterator<String>>;
  cost: () => Promise<AsyncIterator<Float>>;
  printInLabel: () => Promise<AsyncIterator<Boolean>>;
  printInInvoice: () => Promise<AsyncIterator<Boolean>>;
  printInDN: () => Promise<AsyncIterator<Boolean>>;
  wholeSalePrice1: () => Promise<AsyncIterator<Float>>;
  wholeSalePrice2: () => Promise<AsyncIterator<Float>>;
  wholeSalePrice3: () => Promise<AsyncIterator<Float>>;
  wholeSalePrice4: () => Promise<AsyncIterator<Float>>;
  wholeSalePrice5: () => Promise<AsyncIterator<Float>>;
  retailPrice1: () => Promise<AsyncIterator<Float>>;
  retailPrice2: () => Promise<AsyncIterator<Float>>;
  retailPrice3: () => Promise<AsyncIterator<Float>>;
  retailPrice4: () => Promise<AsyncIterator<Float>>;
  retailPrice5: () => Promise<AsyncIterator<Float>>;
  minOrderQuantity: () => Promise<AsyncIterator<Float>>;
  minStockLevel: () => Promise<AsyncIterator<Float>>;
  onlineDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  offlineDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductImage {
  src: String;
  title: String;
}

export interface ProductImagePromise
  extends Promise<ProductImage>,
    Fragmentable {
  src: () => Promise<String>;
  title: () => Promise<String>;
}

export interface ProductImageSubscription
  extends Promise<AsyncIterator<ProductImage>>,
    Fragmentable {
  src: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface ProductImageNullablePromise
  extends Promise<ProductImage | null>,
    Fragmentable {
  src: () => Promise<String>;
  title: () => Promise<String>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateProductImage {
  count: Int;
}

export interface AggregateProductImagePromise
  extends Promise<AggregateProductImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductImageSubscription
  extends Promise<AsyncIterator<AggregateProductImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductImageConnection {
  pageInfo: PageInfo;
  edges: ProductImageEdge[];
}

export interface ProductImageConnectionPromise
  extends Promise<ProductImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductImageEdge>>() => T;
  aggregate: <T = AggregateProductImagePromise>() => T;
}

export interface ProductImageConnectionSubscription
  extends Promise<AsyncIterator<ProductImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductImageSubscription>() => T;
}

export interface ProductCategoryEdge {
  node: ProductCategory;
  cursor: String;
}

export interface ProductCategoryEdgePromise
  extends Promise<ProductCategoryEdge>,
    Fragmentable {
  node: <T = ProductCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductCategoryEdgeSubscription
  extends Promise<AsyncIterator<ProductCategoryEdge>>,
    Fragmentable {
  node: <T = ProductCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductCategorySubscriptionPayload {
  mutation: MutationType;
  node: ProductCategory;
  updatedFields: String[];
  previousValues: ProductCategoryPreviousValues;
}

export interface ProductCategorySubscriptionPayloadPromise
  extends Promise<ProductCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductCategoryPreviousValuesPromise>() => T;
}

export interface ProductCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductCategoryPreviousValuesSubscription>() => T;
}

export interface ProductCategory {
  id: ID_Output;
  nameEn: String;
  nameChi: String;
  detail?: String;
}

export interface ProductCategoryPromise
  extends Promise<ProductCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  detail: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductCategorySubscription
  extends Promise<AsyncIterator<ProductCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nameEn: () => Promise<AsyncIterator<String>>;
  nameChi: () => Promise<AsyncIterator<String>>;
  detail: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductCategoryNullablePromise
  extends Promise<ProductCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  detail: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Product {
  id: ID_Output;
  code: String;
  brandEn: String;
  brandChi: String;
  nameEn: String;
  nameChi: String;
  discount?: String;
  package: Int;
  weight: String;
  shortDescription?: String;
  longDescription?: String;
  sku?: String;
  upc: String;
  cost: Float;
  printInLabel?: Boolean;
  printInInvoice?: Boolean;
  printInDN?: Boolean;
  wholeSalePrice1: Float;
  wholeSalePrice2: Float;
  wholeSalePrice3: Float;
  wholeSalePrice4: Float;
  wholeSalePrice5: Float;
  retailPrice1: Float;
  retailPrice2: Float;
  retailPrice3: Float;
  retailPrice4: Float;
  retailPrice5: Float;
  minOrderQuantity: Float;
  minStockLevel: Float;
  onlineDate?: DateTimeOutput;
  offlineDate?: DateTimeOutput;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  brandEn: () => Promise<String>;
  brandChi: () => Promise<String>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  discount: () => Promise<String>;
  package: () => Promise<Int>;
  weight: () => Promise<String>;
  shortDescription: () => Promise<String>;
  longDescription: () => Promise<String>;
  images: <T = FragmentableArray<ProductImage>>(args?: {
    where?: ProductImageWhereInput;
    orderBy?: ProductImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sku: () => Promise<String>;
  upc: () => Promise<String>;
  cost: () => Promise<Float>;
  printInLabel: () => Promise<Boolean>;
  printInInvoice: () => Promise<Boolean>;
  printInDN: () => Promise<Boolean>;
  wholeSalePrice1: () => Promise<Float>;
  wholeSalePrice2: () => Promise<Float>;
  wholeSalePrice3: () => Promise<Float>;
  wholeSalePrice4: () => Promise<Float>;
  wholeSalePrice5: () => Promise<Float>;
  retailPrice1: () => Promise<Float>;
  retailPrice2: () => Promise<Float>;
  retailPrice3: () => Promise<Float>;
  retailPrice4: () => Promise<Float>;
  retailPrice5: () => Promise<Float>;
  minOrderQuantity: () => Promise<Float>;
  minStockLevel: () => Promise<Float>;
  onlineDate: () => Promise<DateTimeOutput>;
  offlineDate: () => Promise<DateTimeOutput>;
  categories: <T = FragmentableArray<ProductCategory>>(args?: {
    where?: ProductCategoryWhereInput;
    orderBy?: ProductCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  brandEn: () => Promise<AsyncIterator<String>>;
  brandChi: () => Promise<AsyncIterator<String>>;
  nameEn: () => Promise<AsyncIterator<String>>;
  nameChi: () => Promise<AsyncIterator<String>>;
  discount: () => Promise<AsyncIterator<String>>;
  package: () => Promise<AsyncIterator<Int>>;
  weight: () => Promise<AsyncIterator<String>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  longDescription: () => Promise<AsyncIterator<String>>;
  images: <T = Promise<AsyncIterator<ProductImageSubscription>>>(args?: {
    where?: ProductImageWhereInput;
    orderBy?: ProductImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sku: () => Promise<AsyncIterator<String>>;
  upc: () => Promise<AsyncIterator<String>>;
  cost: () => Promise<AsyncIterator<Float>>;
  printInLabel: () => Promise<AsyncIterator<Boolean>>;
  printInInvoice: () => Promise<AsyncIterator<Boolean>>;
  printInDN: () => Promise<AsyncIterator<Boolean>>;
  wholeSalePrice1: () => Promise<AsyncIterator<Float>>;
  wholeSalePrice2: () => Promise<AsyncIterator<Float>>;
  wholeSalePrice3: () => Promise<AsyncIterator<Float>>;
  wholeSalePrice4: () => Promise<AsyncIterator<Float>>;
  wholeSalePrice5: () => Promise<AsyncIterator<Float>>;
  retailPrice1: () => Promise<AsyncIterator<Float>>;
  retailPrice2: () => Promise<AsyncIterator<Float>>;
  retailPrice3: () => Promise<AsyncIterator<Float>>;
  retailPrice4: () => Promise<AsyncIterator<Float>>;
  retailPrice5: () => Promise<AsyncIterator<Float>>;
  minOrderQuantity: () => Promise<AsyncIterator<Float>>;
  minStockLevel: () => Promise<AsyncIterator<Float>>;
  onlineDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  offlineDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  categories: <T = Promise<AsyncIterator<ProductCategorySubscription>>>(args?: {
    where?: ProductCategoryWhereInput;
    orderBy?: ProductCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  brandEn: () => Promise<String>;
  brandChi: () => Promise<String>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  discount: () => Promise<String>;
  package: () => Promise<Int>;
  weight: () => Promise<String>;
  shortDescription: () => Promise<String>;
  longDescription: () => Promise<String>;
  images: <T = FragmentableArray<ProductImage>>(args?: {
    where?: ProductImageWhereInput;
    orderBy?: ProductImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sku: () => Promise<String>;
  upc: () => Promise<String>;
  cost: () => Promise<Float>;
  printInLabel: () => Promise<Boolean>;
  printInInvoice: () => Promise<Boolean>;
  printInDN: () => Promise<Boolean>;
  wholeSalePrice1: () => Promise<Float>;
  wholeSalePrice2: () => Promise<Float>;
  wholeSalePrice3: () => Promise<Float>;
  wholeSalePrice4: () => Promise<Float>;
  wholeSalePrice5: () => Promise<Float>;
  retailPrice1: () => Promise<Float>;
  retailPrice2: () => Promise<Float>;
  retailPrice3: () => Promise<Float>;
  retailPrice4: () => Promise<Float>;
  retailPrice5: () => Promise<Float>;
  minOrderQuantity: () => Promise<Float>;
  minStockLevel: () => Promise<Float>;
  onlineDate: () => Promise<DateTimeOutput>;
  offlineDate: () => Promise<DateTimeOutput>;
  categories: <T = FragmentableArray<ProductCategory>>(args?: {
    where?: ProductCategoryWhereInput;
    orderBy?: ProductCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductImageSubscriptionPayload {
  mutation: MutationType;
  node: ProductImage;
  updatedFields: String[];
  previousValues: ProductImagePreviousValues;
}

export interface ProductImageSubscriptionPayloadPromise
  extends Promise<ProductImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductImagePreviousValuesPromise>() => T;
}

export interface ProductImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductImagePreviousValuesSubscription>() => T;
}

export interface AggregateProductCategory {
  count: Int;
}

export interface AggregateProductCategoryPromise
  extends Promise<AggregateProductCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductCategorySubscription
  extends Promise<AsyncIterator<AggregateProductCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductImageEdge {
  node: ProductImage;
  cursor: String;
}

export interface ProductImageEdgePromise
  extends Promise<ProductImageEdge>,
    Fragmentable {
  node: <T = ProductImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductImageEdgeSubscription
  extends Promise<AsyncIterator<ProductImageEdge>>,
    Fragmentable {
  node: <T = ProductImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductCategoryPreviousValues {
  id: ID_Output;
  nameEn: String;
  nameChi: String;
  detail?: String;
}

export interface ProductCategoryPreviousValuesPromise
  extends Promise<ProductCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  detail: () => Promise<String>;
}

export interface ProductCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nameEn: () => Promise<AsyncIterator<String>>;
  nameChi: () => Promise<AsyncIterator<String>>;
  detail: () => Promise<AsyncIterator<String>>;
}

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Product",
    embedded: false
  },
  {
    name: "ProductCategory",
    embedded: false
  },
  {
    name: "ProductImage",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
