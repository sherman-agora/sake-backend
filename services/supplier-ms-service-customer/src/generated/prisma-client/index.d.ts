// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  customerCoupon: (where?: CustomerCouponWhereInput) => Promise<boolean>;
  customerGroup: (where?: CustomerGroupWhereInput) => Promise<boolean>;
  customerShop: (where?: CustomerShopWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  customerCoupon: (
    where: CustomerCouponWhereUniqueInput
  ) => CustomerCouponNullablePromise;
  customerCoupons: (args?: {
    where?: CustomerCouponWhereInput;
    orderBy?: CustomerCouponOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomerCoupon>;
  customerCouponsConnection: (args?: {
    where?: CustomerCouponWhereInput;
    orderBy?: CustomerCouponOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerCouponConnectionPromise;
  customerGroup: (
    where: CustomerGroupWhereUniqueInput
  ) => CustomerGroupNullablePromise;
  customerGroups: (args?: {
    where?: CustomerGroupWhereInput;
    orderBy?: CustomerGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomerGroup>;
  customerGroupsConnection: (args?: {
    where?: CustomerGroupWhereInput;
    orderBy?: CustomerGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerGroupConnectionPromise;
  customerShop: (
    where: CustomerShopWhereUniqueInput
  ) => CustomerShopNullablePromise;
  customerShops: (args?: {
    where?: CustomerShopWhereInput;
    orderBy?: CustomerShopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomerShop>;
  customerShopsConnection: (args?: {
    where?: CustomerShopWhereInput;
    orderBy?: CustomerShopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerShopConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createCustomerCoupon: (
    data: CustomerCouponCreateInput
  ) => CustomerCouponPromise;
  updateCustomerCoupon: (args: {
    data: CustomerCouponUpdateInput;
    where: CustomerCouponWhereUniqueInput;
  }) => CustomerCouponPromise;
  updateManyCustomerCoupons: (args: {
    data: CustomerCouponUpdateManyMutationInput;
    where?: CustomerCouponWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomerCoupon: (args: {
    where: CustomerCouponWhereUniqueInput;
    create: CustomerCouponCreateInput;
    update: CustomerCouponUpdateInput;
  }) => CustomerCouponPromise;
  deleteCustomerCoupon: (
    where: CustomerCouponWhereUniqueInput
  ) => CustomerCouponPromise;
  deleteManyCustomerCoupons: (
    where?: CustomerCouponWhereInput
  ) => BatchPayloadPromise;
  createCustomerGroup: (data: CustomerGroupCreateInput) => CustomerGroupPromise;
  updateCustomerGroup: (args: {
    data: CustomerGroupUpdateInput;
    where: CustomerGroupWhereUniqueInput;
  }) => CustomerGroupPromise;
  updateManyCustomerGroups: (args: {
    data: CustomerGroupUpdateManyMutationInput;
    where?: CustomerGroupWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomerGroup: (args: {
    where: CustomerGroupWhereUniqueInput;
    create: CustomerGroupCreateInput;
    update: CustomerGroupUpdateInput;
  }) => CustomerGroupPromise;
  deleteCustomerGroup: (
    where: CustomerGroupWhereUniqueInput
  ) => CustomerGroupPromise;
  deleteManyCustomerGroups: (
    where?: CustomerGroupWhereInput
  ) => BatchPayloadPromise;
  createCustomerShop: (data: CustomerShopCreateInput) => CustomerShopPromise;
  updateCustomerShop: (args: {
    data: CustomerShopUpdateInput;
    where: CustomerShopWhereUniqueInput;
  }) => CustomerShopPromise;
  updateManyCustomerShops: (args: {
    data: CustomerShopUpdateManyMutationInput;
    where?: CustomerShopWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomerShop: (args: {
    where: CustomerShopWhereUniqueInput;
    create: CustomerShopCreateInput;
    update: CustomerShopUpdateInput;
  }) => CustomerShopPromise;
  deleteCustomerShop: (
    where: CustomerShopWhereUniqueInput
  ) => CustomerShopPromise;
  deleteManyCustomerShops: (
    where?: CustomerShopWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  customerCoupon: (
    where?: CustomerCouponSubscriptionWhereInput
  ) => CustomerCouponSubscriptionPayloadSubscription;
  customerGroup: (
    where?: CustomerGroupSubscriptionWhereInput
  ) => CustomerGroupSubscriptionPayloadSubscription;
  customerShop: (
    where?: CustomerShopSubscriptionWhereInput
  ) => CustomerShopSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CustomerCouponType = "UNLIMITED" | "LIMITED";

export type CustomerCouponState = "PENDING" | "AVAILABLE" | "EMPTY" | "DELETED";

export type CustomerShopOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "nameEn_ASC"
  | "nameEn_DESC"
  | "nameChi_ASC"
  | "nameChi_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "deliverAddress_ASC"
  | "deliverAddress_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "nameEn_ASC"
  | "nameEn_DESC"
  | "nameChi_ASC"
  | "nameChi_DESC"
  | "wholesalePlan_ASC"
  | "wholesalePlan_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "mobile_ASC"
  | "mobile_DESC"
  | "email_ASC"
  | "email_DESC"
  | "billingAddress_ASC"
  | "billingAddress_DESC"
  | "salesman_ASC"
  | "salesman_DESC"
  | "website_ASC"
  | "website_DESC"
  | "remark_ASC"
  | "remark_DESC"
  | "paymentMethod_ASC"
  | "paymentMethod_DESC"
  | "district_ASC"
  | "district_DESC"
  | "logs_ASC"
  | "logs_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CustomerCouponOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "code_ASC"
  | "code_DESC"
  | "state_ASC"
  | "state_DESC"
  | "name_ASC"
  | "name_DESC"
  | "discount_ASC"
  | "discount_DESC";

export type CustomerGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface CustomerGroupUpdateOneRequiredWithoutCustomersInput {
  create?: Maybe<CustomerGroupCreateWithoutCustomersInput>;
  update?: Maybe<CustomerGroupUpdateWithoutCustomersDataInput>;
  upsert?: Maybe<CustomerGroupUpsertWithoutCustomersInput>;
  connect?: Maybe<CustomerGroupWhereUniqueInput>;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
}>;

export interface CustomerCouponUpdateWithWhereUniqueWithoutCustomerInput {
  where: CustomerCouponWhereUniqueInput;
  data: CustomerCouponUpdateWithoutCustomerDataInput;
}

export interface CustomerCouponWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<CustomerCouponType>;
  type_not?: Maybe<CustomerCouponType>;
  type_in?: Maybe<CustomerCouponType[] | CustomerCouponType>;
  type_not_in?: Maybe<CustomerCouponType[] | CustomerCouponType>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  state?: Maybe<CustomerCouponState>;
  state_not?: Maybe<CustomerCouponState>;
  state_in?: Maybe<CustomerCouponState[] | CustomerCouponState>;
  state_not_in?: Maybe<CustomerCouponState[] | CustomerCouponState>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  discount?: Maybe<String>;
  discount_not?: Maybe<String>;
  discount_in?: Maybe<String[] | String>;
  discount_not_in?: Maybe<String[] | String>;
  discount_lt?: Maybe<String>;
  discount_lte?: Maybe<String>;
  discount_gt?: Maybe<String>;
  discount_gte?: Maybe<String>;
  discount_contains?: Maybe<String>;
  discount_not_contains?: Maybe<String>;
  discount_starts_with?: Maybe<String>;
  discount_not_starts_with?: Maybe<String>;
  discount_ends_with?: Maybe<String>;
  discount_not_ends_with?: Maybe<String>;
  customer?: Maybe<CustomerWhereInput>;
  AND?: Maybe<CustomerCouponWhereInput[] | CustomerCouponWhereInput>;
  OR?: Maybe<CustomerCouponWhereInput[] | CustomerCouponWhereInput>;
  NOT?: Maybe<CustomerCouponWhereInput[] | CustomerCouponWhereInput>;
}

export interface CustomerCouponCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  type: CustomerCouponType;
  quantity?: Maybe<Int>;
  code: String;
  state: CustomerCouponState;
  name: String;
  discount: String;
}

export interface CustomerCreateManyWithoutGroupInput {
  create?: Maybe<
    CustomerCreateWithoutGroupInput[] | CustomerCreateWithoutGroupInput
  >;
  connect?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
}

export interface CustomerUpdateInput {
  code?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  phone?: Maybe<String>;
  mobile?: Maybe<String>;
  email?: Maybe<String>;
  billingAddress?: Maybe<String>;
  salesman?: Maybe<String>;
  website?: Maybe<String>;
  remark?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  district?: Maybe<String>;
  logs?: Maybe<String>;
  shops?: Maybe<CustomerShopUpdateManyWithoutCustomerInput>;
  group?: Maybe<CustomerGroupUpdateOneRequiredWithoutCustomersInput>;
  coupons?: Maybe<CustomerCouponUpdateManyWithoutCustomerInput>;
}

export interface CustomerCouponUpdateWithoutCustomerDataInput {
  type?: Maybe<CustomerCouponType>;
  quantity?: Maybe<Int>;
  code?: Maybe<String>;
  state?: Maybe<CustomerCouponState>;
  name?: Maybe<String>;
  discount?: Maybe<String>;
}

export interface CustomerShopUpdateManyWithoutCustomerInput {
  create?: Maybe<
    | CustomerShopCreateWithoutCustomerInput[]
    | CustomerShopCreateWithoutCustomerInput
  >;
  delete?: Maybe<CustomerShopWhereUniqueInput[] | CustomerShopWhereUniqueInput>;
  connect?: Maybe<
    CustomerShopWhereUniqueInput[] | CustomerShopWhereUniqueInput
  >;
  set?: Maybe<CustomerShopWhereUniqueInput[] | CustomerShopWhereUniqueInput>;
  disconnect?: Maybe<
    CustomerShopWhereUniqueInput[] | CustomerShopWhereUniqueInput
  >;
  update?: Maybe<
    | CustomerShopUpdateWithWhereUniqueWithoutCustomerInput[]
    | CustomerShopUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | CustomerShopUpsertWithWhereUniqueWithoutCustomerInput[]
    | CustomerShopUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<
    CustomerShopScalarWhereInput[] | CustomerShopScalarWhereInput
  >;
  updateMany?: Maybe<
    | CustomerShopUpdateManyWithWhereNestedInput[]
    | CustomerShopUpdateManyWithWhereNestedInput
  >;
}

export interface CustomerGroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerGroupWhereInput>;
  AND?: Maybe<
    CustomerGroupSubscriptionWhereInput[] | CustomerGroupSubscriptionWhereInput
  >;
  OR?: Maybe<
    CustomerGroupSubscriptionWhereInput[] | CustomerGroupSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CustomerGroupSubscriptionWhereInput[] | CustomerGroupSubscriptionWhereInput
  >;
}

export interface CustomerShopUpdateWithWhereUniqueWithoutCustomerInput {
  where: CustomerShopWhereUniqueInput;
  data: CustomerShopUpdateWithoutCustomerDataInput;
}

export interface CustomerCouponSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerCouponWhereInput>;
  AND?: Maybe<
    | CustomerCouponSubscriptionWhereInput[]
    | CustomerCouponSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CustomerCouponSubscriptionWhereInput[]
    | CustomerCouponSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CustomerCouponSubscriptionWhereInput[]
    | CustomerCouponSubscriptionWhereInput
  >;
}

export interface CustomerShopUpdateWithoutCustomerDataInput {
  code?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  phone?: Maybe<String>;
  deliverAddress?: Maybe<String>;
  deliveryDay?: Maybe<CustomerShopUpdatedeliveryDayInput>;
}

export interface CustomerShopUpdateManyMutationInput {
  code?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  phone?: Maybe<String>;
  deliverAddress?: Maybe<String>;
  deliveryDay?: Maybe<CustomerShopUpdatedeliveryDayInput>;
}

export interface CustomerShopUpdatedeliveryDayInput {
  set?: Maybe<Int[] | Int>;
}

export interface CustomerUpdateWithoutShopsDataInput {
  code?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  phone?: Maybe<String>;
  mobile?: Maybe<String>;
  email?: Maybe<String>;
  billingAddress?: Maybe<String>;
  salesman?: Maybe<String>;
  website?: Maybe<String>;
  remark?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  district?: Maybe<String>;
  logs?: Maybe<String>;
  group?: Maybe<CustomerGroupUpdateOneRequiredWithoutCustomersInput>;
  coupons?: Maybe<CustomerCouponUpdateManyWithoutCustomerInput>;
}

export interface CustomerShopUpsertWithWhereUniqueWithoutCustomerInput {
  where: CustomerShopWhereUniqueInput;
  update: CustomerShopUpdateWithoutCustomerDataInput;
  create: CustomerShopCreateWithoutCustomerInput;
}

export interface CustomerShopUpdateInput {
  code?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  phone?: Maybe<String>;
  deliverAddress?: Maybe<String>;
  deliveryDay?: Maybe<CustomerShopUpdatedeliveryDayInput>;
  customer?: Maybe<CustomerUpdateOneWithoutShopsInput>;
}

export interface CustomerShopScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameEn_not?: Maybe<String>;
  nameEn_in?: Maybe<String[] | String>;
  nameEn_not_in?: Maybe<String[] | String>;
  nameEn_lt?: Maybe<String>;
  nameEn_lte?: Maybe<String>;
  nameEn_gt?: Maybe<String>;
  nameEn_gte?: Maybe<String>;
  nameEn_contains?: Maybe<String>;
  nameEn_not_contains?: Maybe<String>;
  nameEn_starts_with?: Maybe<String>;
  nameEn_not_starts_with?: Maybe<String>;
  nameEn_ends_with?: Maybe<String>;
  nameEn_not_ends_with?: Maybe<String>;
  nameChi?: Maybe<String>;
  nameChi_not?: Maybe<String>;
  nameChi_in?: Maybe<String[] | String>;
  nameChi_not_in?: Maybe<String[] | String>;
  nameChi_lt?: Maybe<String>;
  nameChi_lte?: Maybe<String>;
  nameChi_gt?: Maybe<String>;
  nameChi_gte?: Maybe<String>;
  nameChi_contains?: Maybe<String>;
  nameChi_not_contains?: Maybe<String>;
  nameChi_starts_with?: Maybe<String>;
  nameChi_not_starts_with?: Maybe<String>;
  nameChi_ends_with?: Maybe<String>;
  nameChi_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  deliverAddress?: Maybe<String>;
  deliverAddress_not?: Maybe<String>;
  deliverAddress_in?: Maybe<String[] | String>;
  deliverAddress_not_in?: Maybe<String[] | String>;
  deliverAddress_lt?: Maybe<String>;
  deliverAddress_lte?: Maybe<String>;
  deliverAddress_gt?: Maybe<String>;
  deliverAddress_gte?: Maybe<String>;
  deliverAddress_contains?: Maybe<String>;
  deliverAddress_not_contains?: Maybe<String>;
  deliverAddress_starts_with?: Maybe<String>;
  deliverAddress_not_starts_with?: Maybe<String>;
  deliverAddress_ends_with?: Maybe<String>;
  deliverAddress_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CustomerShopScalarWhereInput[] | CustomerShopScalarWhereInput>;
  OR?: Maybe<CustomerShopScalarWhereInput[] | CustomerShopScalarWhereInput>;
  NOT?: Maybe<CustomerShopScalarWhereInput[] | CustomerShopScalarWhereInput>;
}

export interface CustomerCreateWithoutShopsInput {
  id?: Maybe<ID_Input>;
  code: String;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  phone?: Maybe<String>;
  mobile?: Maybe<String>;
  email?: Maybe<String>;
  billingAddress?: Maybe<String>;
  salesman?: Maybe<String>;
  website?: Maybe<String>;
  remark?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  district?: Maybe<String>;
  logs?: Maybe<String>;
  group: CustomerGroupCreateOneWithoutCustomersInput;
  coupons?: Maybe<CustomerCouponCreateManyWithoutCustomerInput>;
}

export interface CustomerShopUpdateManyWithWhereNestedInput {
  where: CustomerShopScalarWhereInput;
  data: CustomerShopUpdateManyDataInput;
}

export interface CustomerShopCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  phone?: Maybe<String>;
  deliverAddress?: Maybe<String>;
  deliveryDay?: Maybe<CustomerShopCreatedeliveryDayInput>;
  customer?: Maybe<CustomerCreateOneWithoutShopsInput>;
}

export interface CustomerShopUpdateManyDataInput {
  code?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  phone?: Maybe<String>;
  deliverAddress?: Maybe<String>;
  deliveryDay?: Maybe<CustomerShopUpdatedeliveryDayInput>;
}

export interface CustomerGroupUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface CustomerUpdateManyWithoutGroupInput {
  create?: Maybe<
    CustomerCreateWithoutGroupInput[] | CustomerCreateWithoutGroupInput
  >;
  delete?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  connect?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  set?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  disconnect?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  update?: Maybe<
    | CustomerUpdateWithWhereUniqueWithoutGroupInput[]
    | CustomerUpdateWithWhereUniqueWithoutGroupInput
  >;
  upsert?: Maybe<
    | CustomerUpsertWithWhereUniqueWithoutGroupInput[]
    | CustomerUpsertWithWhereUniqueWithoutGroupInput
  >;
  deleteMany?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
  updateMany?: Maybe<
    | CustomerUpdateManyWithWhereNestedInput[]
    | CustomerUpdateManyWithWhereNestedInput
  >;
}

export interface CustomerUpdateManyWithWhereNestedInput {
  where: CustomerScalarWhereInput;
  data: CustomerUpdateManyDataInput;
}

export interface CustomerGroupUpdateWithoutCustomersDataInput {
  name?: Maybe<String>;
}

export type CustomerShopWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
}>;

export interface CustomerGroupUpsertWithoutCustomersInput {
  update: CustomerGroupUpdateWithoutCustomersDataInput;
  create: CustomerGroupCreateWithoutCustomersInput;
}

export interface CustomerUpdateWithoutGroupDataInput {
  code?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  phone?: Maybe<String>;
  mobile?: Maybe<String>;
  email?: Maybe<String>;
  billingAddress?: Maybe<String>;
  salesman?: Maybe<String>;
  website?: Maybe<String>;
  remark?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  district?: Maybe<String>;
  logs?: Maybe<String>;
  shops?: Maybe<CustomerShopUpdateManyWithoutCustomerInput>;
  coupons?: Maybe<CustomerCouponUpdateManyWithoutCustomerInput>;
}

export interface CustomerCouponUpdateManyWithoutCustomerInput {
  create?: Maybe<
    | CustomerCouponCreateWithoutCustomerInput[]
    | CustomerCouponCreateWithoutCustomerInput
  >;
  delete?: Maybe<
    CustomerCouponWhereUniqueInput[] | CustomerCouponWhereUniqueInput
  >;
  connect?: Maybe<
    CustomerCouponWhereUniqueInput[] | CustomerCouponWhereUniqueInput
  >;
  set?: Maybe<
    CustomerCouponWhereUniqueInput[] | CustomerCouponWhereUniqueInput
  >;
  disconnect?: Maybe<
    CustomerCouponWhereUniqueInput[] | CustomerCouponWhereUniqueInput
  >;
  update?: Maybe<
    | CustomerCouponUpdateWithWhereUniqueWithoutCustomerInput[]
    | CustomerCouponUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | CustomerCouponUpsertWithWhereUniqueWithoutCustomerInput[]
    | CustomerCouponUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<
    CustomerCouponScalarWhereInput[] | CustomerCouponScalarWhereInput
  >;
  updateMany?: Maybe<
    | CustomerCouponUpdateManyWithWhereNestedInput[]
    | CustomerCouponUpdateManyWithWhereNestedInput
  >;
}

export interface CustomerShopCreateManyWithoutCustomerInput {
  create?: Maybe<
    | CustomerShopCreateWithoutCustomerInput[]
    | CustomerShopCreateWithoutCustomerInput
  >;
  connect?: Maybe<
    CustomerShopWhereUniqueInput[] | CustomerShopWhereUniqueInput
  >;
}

export interface CustomerGroupWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  customers_every?: Maybe<CustomerWhereInput>;
  customers_some?: Maybe<CustomerWhereInput>;
  customers_none?: Maybe<CustomerWhereInput>;
  AND?: Maybe<CustomerGroupWhereInput[] | CustomerGroupWhereInput>;
  OR?: Maybe<CustomerGroupWhereInput[] | CustomerGroupWhereInput>;
  NOT?: Maybe<CustomerGroupWhereInput[] | CustomerGroupWhereInput>;
}

export interface CustomerShopCreatedeliveryDayInput {
  set?: Maybe<Int[] | Int>;
}

export interface CustomerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameEn_not?: Maybe<String>;
  nameEn_in?: Maybe<String[] | String>;
  nameEn_not_in?: Maybe<String[] | String>;
  nameEn_lt?: Maybe<String>;
  nameEn_lte?: Maybe<String>;
  nameEn_gt?: Maybe<String>;
  nameEn_gte?: Maybe<String>;
  nameEn_contains?: Maybe<String>;
  nameEn_not_contains?: Maybe<String>;
  nameEn_starts_with?: Maybe<String>;
  nameEn_not_starts_with?: Maybe<String>;
  nameEn_ends_with?: Maybe<String>;
  nameEn_not_ends_with?: Maybe<String>;
  nameChi?: Maybe<String>;
  nameChi_not?: Maybe<String>;
  nameChi_in?: Maybe<String[] | String>;
  nameChi_not_in?: Maybe<String[] | String>;
  nameChi_lt?: Maybe<String>;
  nameChi_lte?: Maybe<String>;
  nameChi_gt?: Maybe<String>;
  nameChi_gte?: Maybe<String>;
  nameChi_contains?: Maybe<String>;
  nameChi_not_contains?: Maybe<String>;
  nameChi_starts_with?: Maybe<String>;
  nameChi_not_starts_with?: Maybe<String>;
  nameChi_ends_with?: Maybe<String>;
  nameChi_not_ends_with?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  wholesalePlan_not?: Maybe<Int>;
  wholesalePlan_in?: Maybe<Int[] | Int>;
  wholesalePlan_not_in?: Maybe<Int[] | Int>;
  wholesalePlan_lt?: Maybe<Int>;
  wholesalePlan_lte?: Maybe<Int>;
  wholesalePlan_gt?: Maybe<Int>;
  wholesalePlan_gte?: Maybe<Int>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  billingAddress?: Maybe<String>;
  billingAddress_not?: Maybe<String>;
  billingAddress_in?: Maybe<String[] | String>;
  billingAddress_not_in?: Maybe<String[] | String>;
  billingAddress_lt?: Maybe<String>;
  billingAddress_lte?: Maybe<String>;
  billingAddress_gt?: Maybe<String>;
  billingAddress_gte?: Maybe<String>;
  billingAddress_contains?: Maybe<String>;
  billingAddress_not_contains?: Maybe<String>;
  billingAddress_starts_with?: Maybe<String>;
  billingAddress_not_starts_with?: Maybe<String>;
  billingAddress_ends_with?: Maybe<String>;
  billingAddress_not_ends_with?: Maybe<String>;
  salesman?: Maybe<String>;
  salesman_not?: Maybe<String>;
  salesman_in?: Maybe<String[] | String>;
  salesman_not_in?: Maybe<String[] | String>;
  salesman_lt?: Maybe<String>;
  salesman_lte?: Maybe<String>;
  salesman_gt?: Maybe<String>;
  salesman_gte?: Maybe<String>;
  salesman_contains?: Maybe<String>;
  salesman_not_contains?: Maybe<String>;
  salesman_starts_with?: Maybe<String>;
  salesman_not_starts_with?: Maybe<String>;
  salesman_ends_with?: Maybe<String>;
  salesman_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  remark?: Maybe<String>;
  remark_not?: Maybe<String>;
  remark_in?: Maybe<String[] | String>;
  remark_not_in?: Maybe<String[] | String>;
  remark_lt?: Maybe<String>;
  remark_lte?: Maybe<String>;
  remark_gt?: Maybe<String>;
  remark_gte?: Maybe<String>;
  remark_contains?: Maybe<String>;
  remark_not_contains?: Maybe<String>;
  remark_starts_with?: Maybe<String>;
  remark_not_starts_with?: Maybe<String>;
  remark_ends_with?: Maybe<String>;
  remark_not_ends_with?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  paymentMethod_not?: Maybe<String>;
  paymentMethod_in?: Maybe<String[] | String>;
  paymentMethod_not_in?: Maybe<String[] | String>;
  paymentMethod_lt?: Maybe<String>;
  paymentMethod_lte?: Maybe<String>;
  paymentMethod_gt?: Maybe<String>;
  paymentMethod_gte?: Maybe<String>;
  paymentMethod_contains?: Maybe<String>;
  paymentMethod_not_contains?: Maybe<String>;
  paymentMethod_starts_with?: Maybe<String>;
  paymentMethod_not_starts_with?: Maybe<String>;
  paymentMethod_ends_with?: Maybe<String>;
  paymentMethod_not_ends_with?: Maybe<String>;
  district?: Maybe<String>;
  district_not?: Maybe<String>;
  district_in?: Maybe<String[] | String>;
  district_not_in?: Maybe<String[] | String>;
  district_lt?: Maybe<String>;
  district_lte?: Maybe<String>;
  district_gt?: Maybe<String>;
  district_gte?: Maybe<String>;
  district_contains?: Maybe<String>;
  district_not_contains?: Maybe<String>;
  district_starts_with?: Maybe<String>;
  district_not_starts_with?: Maybe<String>;
  district_ends_with?: Maybe<String>;
  district_not_ends_with?: Maybe<String>;
  logs?: Maybe<String>;
  logs_not?: Maybe<String>;
  logs_in?: Maybe<String[] | String>;
  logs_not_in?: Maybe<String[] | String>;
  logs_lt?: Maybe<String>;
  logs_lte?: Maybe<String>;
  logs_gt?: Maybe<String>;
  logs_gte?: Maybe<String>;
  logs_contains?: Maybe<String>;
  logs_not_contains?: Maybe<String>;
  logs_starts_with?: Maybe<String>;
  logs_not_starts_with?: Maybe<String>;
  logs_ends_with?: Maybe<String>;
  logs_not_ends_with?: Maybe<String>;
  shops_every?: Maybe<CustomerShopWhereInput>;
  shops_some?: Maybe<CustomerShopWhereInput>;
  shops_none?: Maybe<CustomerShopWhereInput>;
  group?: Maybe<CustomerGroupWhereInput>;
  coupons_every?: Maybe<CustomerCouponWhereInput>;
  coupons_some?: Maybe<CustomerCouponWhereInput>;
  coupons_none?: Maybe<CustomerCouponWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  OR?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  NOT?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface CustomerGroupCreateWithoutCustomersInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface CustomerCouponUpsertWithWhereUniqueWithoutCustomerInput {
  where: CustomerCouponWhereUniqueInput;
  update: CustomerCouponUpdateWithoutCustomerDataInput;
  create: CustomerCouponCreateWithoutCustomerInput;
}

export interface CustomerShopSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerShopWhereInput>;
  AND?: Maybe<
    CustomerShopSubscriptionWhereInput[] | CustomerShopSubscriptionWhereInput
  >;
  OR?: Maybe<
    CustomerShopSubscriptionWhereInput[] | CustomerShopSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CustomerShopSubscriptionWhereInput[] | CustomerShopSubscriptionWhereInput
  >;
}

export interface CustomerCouponScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<CustomerCouponType>;
  type_not?: Maybe<CustomerCouponType>;
  type_in?: Maybe<CustomerCouponType[] | CustomerCouponType>;
  type_not_in?: Maybe<CustomerCouponType[] | CustomerCouponType>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  state?: Maybe<CustomerCouponState>;
  state_not?: Maybe<CustomerCouponState>;
  state_in?: Maybe<CustomerCouponState[] | CustomerCouponState>;
  state_not_in?: Maybe<CustomerCouponState[] | CustomerCouponState>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  discount?: Maybe<String>;
  discount_not?: Maybe<String>;
  discount_in?: Maybe<String[] | String>;
  discount_not_in?: Maybe<String[] | String>;
  discount_lt?: Maybe<String>;
  discount_lte?: Maybe<String>;
  discount_gt?: Maybe<String>;
  discount_gte?: Maybe<String>;
  discount_contains?: Maybe<String>;
  discount_not_contains?: Maybe<String>;
  discount_starts_with?: Maybe<String>;
  discount_not_starts_with?: Maybe<String>;
  discount_ends_with?: Maybe<String>;
  discount_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    CustomerCouponScalarWhereInput[] | CustomerCouponScalarWhereInput
  >;
  OR?: Maybe<CustomerCouponScalarWhereInput[] | CustomerCouponScalarWhereInput>;
  NOT?: Maybe<
    CustomerCouponScalarWhereInput[] | CustomerCouponScalarWhereInput
  >;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
  OR?: Maybe<CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput>;
  NOT?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export interface CustomerCouponUpdateManyWithWhereNestedInput {
  where: CustomerCouponScalarWhereInput;
  data: CustomerCouponUpdateManyDataInput;
}

export interface CustomerUpdateOneWithoutShopsInput {
  create?: Maybe<CustomerCreateWithoutShopsInput>;
  update?: Maybe<CustomerUpdateWithoutShopsDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutShopsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCouponUpdateManyDataInput {
  type?: Maybe<CustomerCouponType>;
  quantity?: Maybe<Int>;
  code?: Maybe<String>;
  state?: Maybe<CustomerCouponState>;
  name?: Maybe<String>;
  discount?: Maybe<String>;
}

export interface CustomerCreateOneWithoutShopsInput {
  create?: Maybe<CustomerCreateWithoutShopsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateManyMutationInput {
  code?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  phone?: Maybe<String>;
  mobile?: Maybe<String>;
  email?: Maybe<String>;
  billingAddress?: Maybe<String>;
  salesman?: Maybe<String>;
  website?: Maybe<String>;
  remark?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  district?: Maybe<String>;
  logs?: Maybe<String>;
}

export interface CustomerUpdateManyDataInput {
  code?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  phone?: Maybe<String>;
  mobile?: Maybe<String>;
  email?: Maybe<String>;
  billingAddress?: Maybe<String>;
  salesman?: Maybe<String>;
  website?: Maybe<String>;
  remark?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  district?: Maybe<String>;
  logs?: Maybe<String>;
}

export interface CustomerGroupUpdateInput {
  name?: Maybe<String>;
  customers?: Maybe<CustomerUpdateManyWithoutGroupInput>;
}

export interface CustomerUpsertWithWhereUniqueWithoutGroupInput {
  where: CustomerWhereUniqueInput;
  update: CustomerUpdateWithoutGroupDataInput;
  create: CustomerCreateWithoutGroupInput;
}

export interface CustomerCreateWithoutGroupInput {
  id?: Maybe<ID_Input>;
  code: String;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  phone?: Maybe<String>;
  mobile?: Maybe<String>;
  email?: Maybe<String>;
  billingAddress?: Maybe<String>;
  salesman?: Maybe<String>;
  website?: Maybe<String>;
  remark?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  district?: Maybe<String>;
  logs?: Maybe<String>;
  shops?: Maybe<CustomerShopCreateManyWithoutCustomerInput>;
  coupons?: Maybe<CustomerCouponCreateManyWithoutCustomerInput>;
}

export interface CustomerCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  phone?: Maybe<String>;
  mobile?: Maybe<String>;
  email?: Maybe<String>;
  billingAddress?: Maybe<String>;
  salesman?: Maybe<String>;
  website?: Maybe<String>;
  remark?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  district?: Maybe<String>;
  logs?: Maybe<String>;
  shops?: Maybe<CustomerShopCreateManyWithoutCustomerInput>;
  group: CustomerGroupCreateOneWithoutCustomersInput;
  coupons?: Maybe<CustomerCouponCreateManyWithoutCustomerInput>;
}

export interface CustomerCouponCreateInput {
  id?: Maybe<ID_Input>;
  type: CustomerCouponType;
  quantity?: Maybe<Int>;
  code: String;
  state: CustomerCouponState;
  name: String;
  discount: String;
  customer: CustomerCreateOneWithoutCouponsInput;
}

export interface CustomerGroupCreateOneWithoutCustomersInput {
  create?: Maybe<CustomerGroupCreateWithoutCustomersInput>;
  connect?: Maybe<CustomerGroupWhereUniqueInput>;
}

export interface CustomerCreateOneWithoutCouponsInput {
  create?: Maybe<CustomerCreateWithoutCouponsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerShopWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameEn_not?: Maybe<String>;
  nameEn_in?: Maybe<String[] | String>;
  nameEn_not_in?: Maybe<String[] | String>;
  nameEn_lt?: Maybe<String>;
  nameEn_lte?: Maybe<String>;
  nameEn_gt?: Maybe<String>;
  nameEn_gte?: Maybe<String>;
  nameEn_contains?: Maybe<String>;
  nameEn_not_contains?: Maybe<String>;
  nameEn_starts_with?: Maybe<String>;
  nameEn_not_starts_with?: Maybe<String>;
  nameEn_ends_with?: Maybe<String>;
  nameEn_not_ends_with?: Maybe<String>;
  nameChi?: Maybe<String>;
  nameChi_not?: Maybe<String>;
  nameChi_in?: Maybe<String[] | String>;
  nameChi_not_in?: Maybe<String[] | String>;
  nameChi_lt?: Maybe<String>;
  nameChi_lte?: Maybe<String>;
  nameChi_gt?: Maybe<String>;
  nameChi_gte?: Maybe<String>;
  nameChi_contains?: Maybe<String>;
  nameChi_not_contains?: Maybe<String>;
  nameChi_starts_with?: Maybe<String>;
  nameChi_not_starts_with?: Maybe<String>;
  nameChi_ends_with?: Maybe<String>;
  nameChi_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  deliverAddress?: Maybe<String>;
  deliverAddress_not?: Maybe<String>;
  deliverAddress_in?: Maybe<String[] | String>;
  deliverAddress_not_in?: Maybe<String[] | String>;
  deliverAddress_lt?: Maybe<String>;
  deliverAddress_lte?: Maybe<String>;
  deliverAddress_gt?: Maybe<String>;
  deliverAddress_gte?: Maybe<String>;
  deliverAddress_contains?: Maybe<String>;
  deliverAddress_not_contains?: Maybe<String>;
  deliverAddress_starts_with?: Maybe<String>;
  deliverAddress_not_starts_with?: Maybe<String>;
  deliverAddress_ends_with?: Maybe<String>;
  deliverAddress_not_ends_with?: Maybe<String>;
  customer?: Maybe<CustomerWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CustomerShopWhereInput[] | CustomerShopWhereInput>;
  OR?: Maybe<CustomerShopWhereInput[] | CustomerShopWhereInput>;
  NOT?: Maybe<CustomerShopWhereInput[] | CustomerShopWhereInput>;
}

export interface CustomerCreateWithoutCouponsInput {
  id?: Maybe<ID_Input>;
  code: String;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  phone?: Maybe<String>;
  mobile?: Maybe<String>;
  email?: Maybe<String>;
  billingAddress?: Maybe<String>;
  salesman?: Maybe<String>;
  website?: Maybe<String>;
  remark?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  district?: Maybe<String>;
  logs?: Maybe<String>;
  shops?: Maybe<CustomerShopCreateManyWithoutCustomerInput>;
  group: CustomerGroupCreateOneWithoutCustomersInput;
}

export type CustomerCouponWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
}>;

export interface CustomerCouponUpdateInput {
  type?: Maybe<CustomerCouponType>;
  quantity?: Maybe<Int>;
  code?: Maybe<String>;
  state?: Maybe<CustomerCouponState>;
  name?: Maybe<String>;
  discount?: Maybe<String>;
  customer?: Maybe<CustomerUpdateOneRequiredWithoutCouponsInput>;
}

export interface CustomerScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameEn_not?: Maybe<String>;
  nameEn_in?: Maybe<String[] | String>;
  nameEn_not_in?: Maybe<String[] | String>;
  nameEn_lt?: Maybe<String>;
  nameEn_lte?: Maybe<String>;
  nameEn_gt?: Maybe<String>;
  nameEn_gte?: Maybe<String>;
  nameEn_contains?: Maybe<String>;
  nameEn_not_contains?: Maybe<String>;
  nameEn_starts_with?: Maybe<String>;
  nameEn_not_starts_with?: Maybe<String>;
  nameEn_ends_with?: Maybe<String>;
  nameEn_not_ends_with?: Maybe<String>;
  nameChi?: Maybe<String>;
  nameChi_not?: Maybe<String>;
  nameChi_in?: Maybe<String[] | String>;
  nameChi_not_in?: Maybe<String[] | String>;
  nameChi_lt?: Maybe<String>;
  nameChi_lte?: Maybe<String>;
  nameChi_gt?: Maybe<String>;
  nameChi_gte?: Maybe<String>;
  nameChi_contains?: Maybe<String>;
  nameChi_not_contains?: Maybe<String>;
  nameChi_starts_with?: Maybe<String>;
  nameChi_not_starts_with?: Maybe<String>;
  nameChi_ends_with?: Maybe<String>;
  nameChi_not_ends_with?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  wholesalePlan_not?: Maybe<Int>;
  wholesalePlan_in?: Maybe<Int[] | Int>;
  wholesalePlan_not_in?: Maybe<Int[] | Int>;
  wholesalePlan_lt?: Maybe<Int>;
  wholesalePlan_lte?: Maybe<Int>;
  wholesalePlan_gt?: Maybe<Int>;
  wholesalePlan_gte?: Maybe<Int>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  billingAddress?: Maybe<String>;
  billingAddress_not?: Maybe<String>;
  billingAddress_in?: Maybe<String[] | String>;
  billingAddress_not_in?: Maybe<String[] | String>;
  billingAddress_lt?: Maybe<String>;
  billingAddress_lte?: Maybe<String>;
  billingAddress_gt?: Maybe<String>;
  billingAddress_gte?: Maybe<String>;
  billingAddress_contains?: Maybe<String>;
  billingAddress_not_contains?: Maybe<String>;
  billingAddress_starts_with?: Maybe<String>;
  billingAddress_not_starts_with?: Maybe<String>;
  billingAddress_ends_with?: Maybe<String>;
  billingAddress_not_ends_with?: Maybe<String>;
  salesman?: Maybe<String>;
  salesman_not?: Maybe<String>;
  salesman_in?: Maybe<String[] | String>;
  salesman_not_in?: Maybe<String[] | String>;
  salesman_lt?: Maybe<String>;
  salesman_lte?: Maybe<String>;
  salesman_gt?: Maybe<String>;
  salesman_gte?: Maybe<String>;
  salesman_contains?: Maybe<String>;
  salesman_not_contains?: Maybe<String>;
  salesman_starts_with?: Maybe<String>;
  salesman_not_starts_with?: Maybe<String>;
  salesman_ends_with?: Maybe<String>;
  salesman_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  remark?: Maybe<String>;
  remark_not?: Maybe<String>;
  remark_in?: Maybe<String[] | String>;
  remark_not_in?: Maybe<String[] | String>;
  remark_lt?: Maybe<String>;
  remark_lte?: Maybe<String>;
  remark_gt?: Maybe<String>;
  remark_gte?: Maybe<String>;
  remark_contains?: Maybe<String>;
  remark_not_contains?: Maybe<String>;
  remark_starts_with?: Maybe<String>;
  remark_not_starts_with?: Maybe<String>;
  remark_ends_with?: Maybe<String>;
  remark_not_ends_with?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  paymentMethod_not?: Maybe<String>;
  paymentMethod_in?: Maybe<String[] | String>;
  paymentMethod_not_in?: Maybe<String[] | String>;
  paymentMethod_lt?: Maybe<String>;
  paymentMethod_lte?: Maybe<String>;
  paymentMethod_gt?: Maybe<String>;
  paymentMethod_gte?: Maybe<String>;
  paymentMethod_contains?: Maybe<String>;
  paymentMethod_not_contains?: Maybe<String>;
  paymentMethod_starts_with?: Maybe<String>;
  paymentMethod_not_starts_with?: Maybe<String>;
  paymentMethod_ends_with?: Maybe<String>;
  paymentMethod_not_ends_with?: Maybe<String>;
  district?: Maybe<String>;
  district_not?: Maybe<String>;
  district_in?: Maybe<String[] | String>;
  district_not_in?: Maybe<String[] | String>;
  district_lt?: Maybe<String>;
  district_lte?: Maybe<String>;
  district_gt?: Maybe<String>;
  district_gte?: Maybe<String>;
  district_contains?: Maybe<String>;
  district_not_contains?: Maybe<String>;
  district_starts_with?: Maybe<String>;
  district_not_starts_with?: Maybe<String>;
  district_ends_with?: Maybe<String>;
  district_not_ends_with?: Maybe<String>;
  logs?: Maybe<String>;
  logs_not?: Maybe<String>;
  logs_in?: Maybe<String[] | String>;
  logs_not_in?: Maybe<String[] | String>;
  logs_lt?: Maybe<String>;
  logs_lte?: Maybe<String>;
  logs_gt?: Maybe<String>;
  logs_gte?: Maybe<String>;
  logs_contains?: Maybe<String>;
  logs_not_contains?: Maybe<String>;
  logs_starts_with?: Maybe<String>;
  logs_not_starts_with?: Maybe<String>;
  logs_ends_with?: Maybe<String>;
  logs_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
  OR?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
  NOT?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
}

export interface CustomerUpdateOneRequiredWithoutCouponsInput {
  create?: Maybe<CustomerCreateWithoutCouponsInput>;
  update?: Maybe<CustomerUpdateWithoutCouponsDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutCouponsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerShopCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  code: String;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  phone?: Maybe<String>;
  deliverAddress?: Maybe<String>;
  deliveryDay?: Maybe<CustomerShopCreatedeliveryDayInput>;
}

export interface CustomerGroupCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  customers?: Maybe<CustomerCreateManyWithoutGroupInput>;
}

export interface CustomerCouponUpdateManyMutationInput {
  type?: Maybe<CustomerCouponType>;
  quantity?: Maybe<Int>;
  code?: Maybe<String>;
  state?: Maybe<CustomerCouponState>;
  name?: Maybe<String>;
  discount?: Maybe<String>;
}

export interface CustomerUpsertWithoutCouponsInput {
  update: CustomerUpdateWithoutCouponsDataInput;
  create: CustomerCreateWithoutCouponsInput;
}

export interface CustomerUpdateWithoutCouponsDataInput {
  code?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameChi?: Maybe<String>;
  wholesalePlan?: Maybe<Int>;
  phone?: Maybe<String>;
  mobile?: Maybe<String>;
  email?: Maybe<String>;
  billingAddress?: Maybe<String>;
  salesman?: Maybe<String>;
  website?: Maybe<String>;
  remark?: Maybe<String>;
  paymentMethod?: Maybe<String>;
  district?: Maybe<String>;
  logs?: Maybe<String>;
  shops?: Maybe<CustomerShopUpdateManyWithoutCustomerInput>;
  group?: Maybe<CustomerGroupUpdateOneRequiredWithoutCustomersInput>;
}

export interface CustomerCouponCreateManyWithoutCustomerInput {
  create?: Maybe<
    | CustomerCouponCreateWithoutCustomerInput[]
    | CustomerCouponCreateWithoutCustomerInput
  >;
  connect?: Maybe<
    CustomerCouponWhereUniqueInput[] | CustomerCouponWhereUniqueInput
  >;
}

export interface CustomerUpdateWithWhereUniqueWithoutGroupInput {
  where: CustomerWhereUniqueInput;
  data: CustomerUpdateWithoutGroupDataInput;
}

export type CustomerGroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface CustomerUpsertWithoutShopsInput {
  update: CustomerUpdateWithoutShopsDataInput;
  create: CustomerCreateWithoutShopsInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface CustomerShopPreviousValues {
  id: ID_Output;
  code: String;
  nameEn?: String;
  nameChi?: String;
  phone?: String;
  deliverAddress?: String;
  deliveryDay: Int[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerShopPreviousValuesPromise
  extends Promise<CustomerShopPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  phone: () => Promise<String>;
  deliverAddress: () => Promise<String>;
  deliveryDay: () => Promise<Int[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerShopPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerShopPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  nameEn: () => Promise<AsyncIterator<String>>;
  nameChi: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  deliverAddress: () => Promise<AsyncIterator<String>>;
  deliveryDay: () => Promise<AsyncIterator<Int[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerGroupSubscriptionPayload {
  mutation: MutationType;
  node: CustomerGroup;
  updatedFields: String[];
  previousValues: CustomerGroupPreviousValues;
}

export interface CustomerGroupSubscriptionPayloadPromise
  extends Promise<CustomerGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerGroupPreviousValuesPromise>() => T;
}

export interface CustomerGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerGroupPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateCustomerShop {
  count: Int;
}

export interface AggregateCustomerShopPromise
  extends Promise<AggregateCustomerShop>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerShopSubscription
  extends Promise<AsyncIterator<AggregateCustomerShop>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerShopConnection {
  pageInfo: PageInfo;
  edges: CustomerShopEdge[];
}

export interface CustomerShopConnectionPromise
  extends Promise<CustomerShopConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerShopEdge>>() => T;
  aggregate: <T = AggregateCustomerShopPromise>() => T;
}

export interface CustomerShopConnectionSubscription
  extends Promise<AsyncIterator<CustomerShopConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerShopEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerShopSubscription>() => T;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface CustomerGroupEdge {
  node: CustomerGroup;
  cursor: String;
}

export interface CustomerGroupEdgePromise
  extends Promise<CustomerGroupEdge>,
    Fragmentable {
  node: <T = CustomerGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerGroupEdgeSubscription
  extends Promise<AsyncIterator<CustomerGroupEdge>>,
    Fragmentable {
  node: <T = CustomerGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerCoupon {
  id: ID_Output;
  type: CustomerCouponType;
  quantity: Int;
  code: String;
  state: CustomerCouponState;
  name: String;
  discount: String;
}

export interface CustomerCouponPromise
  extends Promise<CustomerCoupon>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<CustomerCouponType>;
  quantity: () => Promise<Int>;
  code: () => Promise<String>;
  state: () => Promise<CustomerCouponState>;
  name: () => Promise<String>;
  discount: () => Promise<String>;
  customer: <T = CustomerPromise>() => T;
}

export interface CustomerCouponSubscription
  extends Promise<AsyncIterator<CustomerCoupon>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<CustomerCouponType>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  code: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<CustomerCouponState>>;
  name: () => Promise<AsyncIterator<String>>;
  discount: () => Promise<AsyncIterator<String>>;
  customer: <T = CustomerSubscription>() => T;
}

export interface CustomerCouponNullablePromise
  extends Promise<CustomerCoupon | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<CustomerCouponType>;
  quantity: () => Promise<Int>;
  code: () => Promise<String>;
  state: () => Promise<CustomerCouponState>;
  name: () => Promise<String>;
  discount: () => Promise<String>;
  customer: <T = CustomerPromise>() => T;
}

export interface Customer {
  id: ID_Output;
  code: String;
  nameEn?: String;
  nameChi?: String;
  wholesalePlan?: Int;
  phone?: String;
  mobile?: String;
  email?: String;
  billingAddress?: String;
  salesman?: String;
  website?: String;
  remark?: String;
  paymentMethod?: String;
  district?: String;
  logs?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  wholesalePlan: () => Promise<Int>;
  phone: () => Promise<String>;
  mobile: () => Promise<String>;
  email: () => Promise<String>;
  billingAddress: () => Promise<String>;
  salesman: () => Promise<String>;
  website: () => Promise<String>;
  remark: () => Promise<String>;
  paymentMethod: () => Promise<String>;
  district: () => Promise<String>;
  logs: () => Promise<String>;
  shops: <T = FragmentableArray<CustomerShop>>(args?: {
    where?: CustomerShopWhereInput;
    orderBy?: CustomerShopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  group: <T = CustomerGroupPromise>() => T;
  coupons: <T = FragmentableArray<CustomerCoupon>>(args?: {
    where?: CustomerCouponWhereInput;
    orderBy?: CustomerCouponOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  nameEn: () => Promise<AsyncIterator<String>>;
  nameChi: () => Promise<AsyncIterator<String>>;
  wholesalePlan: () => Promise<AsyncIterator<Int>>;
  phone: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  billingAddress: () => Promise<AsyncIterator<String>>;
  salesman: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  remark: () => Promise<AsyncIterator<String>>;
  paymentMethod: () => Promise<AsyncIterator<String>>;
  district: () => Promise<AsyncIterator<String>>;
  logs: () => Promise<AsyncIterator<String>>;
  shops: <T = Promise<AsyncIterator<CustomerShopSubscription>>>(args?: {
    where?: CustomerShopWhereInput;
    orderBy?: CustomerShopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  group: <T = CustomerGroupSubscription>() => T;
  coupons: <T = Promise<AsyncIterator<CustomerCouponSubscription>>>(args?: {
    where?: CustomerCouponWhereInput;
    orderBy?: CustomerCouponOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  wholesalePlan: () => Promise<Int>;
  phone: () => Promise<String>;
  mobile: () => Promise<String>;
  email: () => Promise<String>;
  billingAddress: () => Promise<String>;
  salesman: () => Promise<String>;
  website: () => Promise<String>;
  remark: () => Promise<String>;
  paymentMethod: () => Promise<String>;
  district: () => Promise<String>;
  logs: () => Promise<String>;
  shops: <T = FragmentableArray<CustomerShop>>(args?: {
    where?: CustomerShopWhereInput;
    orderBy?: CustomerShopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  group: <T = CustomerGroupPromise>() => T;
  coupons: <T = FragmentableArray<CustomerCoupon>>(args?: {
    where?: CustomerCouponWhereInput;
    orderBy?: CustomerCouponOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerShop {
  id: ID_Output;
  code: String;
  nameEn?: String;
  nameChi?: String;
  phone?: String;
  deliverAddress?: String;
  deliveryDay: Int[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerShopPromise
  extends Promise<CustomerShop>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  phone: () => Promise<String>;
  deliverAddress: () => Promise<String>;
  deliveryDay: () => Promise<Int[]>;
  customer: <T = CustomerPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerShopSubscription
  extends Promise<AsyncIterator<CustomerShop>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  nameEn: () => Promise<AsyncIterator<String>>;
  nameChi: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  deliverAddress: () => Promise<AsyncIterator<String>>;
  deliveryDay: () => Promise<AsyncIterator<Int[]>>;
  customer: <T = CustomerSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerShopNullablePromise
  extends Promise<CustomerShop | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  phone: () => Promise<String>;
  deliverAddress: () => Promise<String>;
  deliveryDay: () => Promise<Int[]>;
  customer: <T = CustomerPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerCouponEdge {
  node: CustomerCoupon;
  cursor: String;
}

export interface CustomerCouponEdgePromise
  extends Promise<CustomerCouponEdge>,
    Fragmentable {
  node: <T = CustomerCouponPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerCouponEdgeSubscription
  extends Promise<AsyncIterator<CustomerCouponEdge>>,
    Fragmentable {
  node: <T = CustomerCouponSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  code: String;
  nameEn?: String;
  nameChi?: String;
  wholesalePlan?: Int;
  phone?: String;
  mobile?: String;
  email?: String;
  billingAddress?: String;
  salesman?: String;
  website?: String;
  remark?: String;
  paymentMethod?: String;
  district?: String;
  logs?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  nameEn: () => Promise<String>;
  nameChi: () => Promise<String>;
  wholesalePlan: () => Promise<Int>;
  phone: () => Promise<String>;
  mobile: () => Promise<String>;
  email: () => Promise<String>;
  billingAddress: () => Promise<String>;
  salesman: () => Promise<String>;
  website: () => Promise<String>;
  remark: () => Promise<String>;
  paymentMethod: () => Promise<String>;
  district: () => Promise<String>;
  logs: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  nameEn: () => Promise<AsyncIterator<String>>;
  nameChi: () => Promise<AsyncIterator<String>>;
  wholesalePlan: () => Promise<AsyncIterator<Int>>;
  phone: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  billingAddress: () => Promise<AsyncIterator<String>>;
  salesman: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  remark: () => Promise<AsyncIterator<String>>;
  paymentMethod: () => Promise<AsyncIterator<String>>;
  district: () => Promise<AsyncIterator<String>>;
  logs: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerShopEdge {
  node: CustomerShop;
  cursor: String;
}

export interface CustomerShopEdgePromise
  extends Promise<CustomerShopEdge>,
    Fragmentable {
  node: <T = CustomerShopPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerShopEdgeSubscription
  extends Promise<AsyncIterator<CustomerShopEdge>>,
    Fragmentable {
  node: <T = CustomerShopSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerGroup {
  id: ID_Output;
  name: String;
}

export interface CustomerGroupPromise
  extends Promise<CustomerGroup>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  customers: <T = FragmentableArray<Customer>>(args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerGroupSubscription
  extends Promise<AsyncIterator<CustomerGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  customers: <T = Promise<AsyncIterator<CustomerSubscription>>>(args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerGroupNullablePromise
  extends Promise<CustomerGroup | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  customers: <T = FragmentableArray<Customer>>(args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerCouponPreviousValues {
  id: ID_Output;
  type: CustomerCouponType;
  quantity: Int;
  code: String;
  state: CustomerCouponState;
  name: String;
  discount: String;
}

export interface CustomerCouponPreviousValuesPromise
  extends Promise<CustomerCouponPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<CustomerCouponType>;
  quantity: () => Promise<Int>;
  code: () => Promise<String>;
  state: () => Promise<CustomerCouponState>;
  name: () => Promise<String>;
  discount: () => Promise<String>;
}

export interface CustomerCouponPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerCouponPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<CustomerCouponType>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  code: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<CustomerCouponState>>;
  name: () => Promise<AsyncIterator<String>>;
  discount: () => Promise<AsyncIterator<String>>;
}

export interface CustomerCouponSubscriptionPayload {
  mutation: MutationType;
  node: CustomerCoupon;
  updatedFields: String[];
  previousValues: CustomerCouponPreviousValues;
}

export interface CustomerCouponSubscriptionPayloadPromise
  extends Promise<CustomerCouponSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerCouponPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerCouponPreviousValuesPromise>() => T;
}

export interface CustomerCouponSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerCouponSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerCouponSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerCouponPreviousValuesSubscription>() => T;
}

export interface CustomerGroupPreviousValues {
  id: ID_Output;
  name: String;
}

export interface CustomerGroupPreviousValuesPromise
  extends Promise<CustomerGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CustomerGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomerGroup {
  count: Int;
}

export interface AggregateCustomerGroupPromise
  extends Promise<AggregateCustomerGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerGroupSubscription
  extends Promise<AsyncIterator<AggregateCustomerGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerShopSubscriptionPayload {
  mutation: MutationType;
  node: CustomerShop;
  updatedFields: String[];
  previousValues: CustomerShopPreviousValues;
}

export interface CustomerShopSubscriptionPayloadPromise
  extends Promise<CustomerShopSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerShopPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerShopPreviousValuesPromise>() => T;
}

export interface CustomerShopSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerShopSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerShopSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerShopPreviousValuesSubscription>() => T;
}

export interface CustomerCouponConnection {
  pageInfo: PageInfo;
  edges: CustomerCouponEdge[];
}

export interface CustomerCouponConnectionPromise
  extends Promise<CustomerCouponConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerCouponEdge>>() => T;
  aggregate: <T = AggregateCustomerCouponPromise>() => T;
}

export interface CustomerCouponConnectionSubscription
  extends Promise<AsyncIterator<CustomerCouponConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerCouponEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerCouponSubscription>() => T;
}

export interface AggregateCustomerCoupon {
  count: Int;
}

export interface AggregateCustomerCouponPromise
  extends Promise<AggregateCustomerCoupon>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerCouponSubscription
  extends Promise<AsyncIterator<AggregateCustomerCoupon>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerGroupConnection {
  pageInfo: PageInfo;
  edges: CustomerGroupEdge[];
}

export interface CustomerGroupConnectionPromise
  extends Promise<CustomerGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerGroupEdge>>() => T;
  aggregate: <T = AggregateCustomerGroupPromise>() => T;
}

export interface CustomerGroupConnectionSubscription
  extends Promise<AsyncIterator<CustomerGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerGroupSubscription>() => T;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "CustomerGroup",
    embedded: false
  },
  {
    name: "CustomerShop",
    embedded: false
  },
  {
    name: "CustomerCoupon",
    embedded: false
  },
  {
    name: "CustomerCouponState",
    embedded: false
  },
  {
    name: "CustomerCouponType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
