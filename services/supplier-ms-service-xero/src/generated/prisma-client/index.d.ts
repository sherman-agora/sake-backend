// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  auth: (where?: AuthWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  redirect: (where?: RedirectWhereInput) => Promise<boolean>;
  xeroUser: (where?: XeroUserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  auth: (where: AuthWhereUniqueInput) => AuthNullablePromise;
  auths: (args?: {
    where?: AuthWhereInput;
    orderBy?: AuthOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Auth>;
  authsConnection: (args?: {
    where?: AuthWhereInput;
    orderBy?: AuthOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AuthConnectionPromise;
  contact: (where: ContactWhereUniqueInput) => ContactNullablePromise;
  contacts: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contact>;
  contactsConnection: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactConnectionPromise;
  redirect: (where: RedirectWhereUniqueInput) => RedirectNullablePromise;
  redirects: (args?: {
    where?: RedirectWhereInput;
    orderBy?: RedirectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Redirect>;
  redirectsConnection: (args?: {
    where?: RedirectWhereInput;
    orderBy?: RedirectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RedirectConnectionPromise;
  xeroUser: (where: XeroUserWhereUniqueInput) => XeroUserNullablePromise;
  xeroUsers: (args?: {
    where?: XeroUserWhereInput;
    orderBy?: XeroUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<XeroUser>;
  xeroUsersConnection: (args?: {
    where?: XeroUserWhereInput;
    orderBy?: XeroUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => XeroUserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAuth: (data: AuthCreateInput) => AuthPromise;
  updateAuth: (args: {
    data: AuthUpdateInput;
    where: AuthWhereUniqueInput;
  }) => AuthPromise;
  updateManyAuths: (args: {
    data: AuthUpdateManyMutationInput;
    where?: AuthWhereInput;
  }) => BatchPayloadPromise;
  upsertAuth: (args: {
    where: AuthWhereUniqueInput;
    create: AuthCreateInput;
    update: AuthUpdateInput;
  }) => AuthPromise;
  deleteAuth: (where: AuthWhereUniqueInput) => AuthPromise;
  deleteManyAuths: (where?: AuthWhereInput) => BatchPayloadPromise;
  createContact: (data: ContactCreateInput) => ContactPromise;
  updateContact: (args: {
    data: ContactUpdateInput;
    where: ContactWhereUniqueInput;
  }) => ContactPromise;
  updateManyContacts: (args: {
    data: ContactUpdateManyMutationInput;
    where?: ContactWhereInput;
  }) => BatchPayloadPromise;
  upsertContact: (args: {
    where: ContactWhereUniqueInput;
    create: ContactCreateInput;
    update: ContactUpdateInput;
  }) => ContactPromise;
  deleteContact: (where: ContactWhereUniqueInput) => ContactPromise;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayloadPromise;
  createRedirect: (data: RedirectCreateInput) => RedirectPromise;
  updateRedirect: (args: {
    data: RedirectUpdateInput;
    where: RedirectWhereUniqueInput;
  }) => RedirectPromise;
  updateManyRedirects: (args: {
    data: RedirectUpdateManyMutationInput;
    where?: RedirectWhereInput;
  }) => BatchPayloadPromise;
  upsertRedirect: (args: {
    where: RedirectWhereUniqueInput;
    create: RedirectCreateInput;
    update: RedirectUpdateInput;
  }) => RedirectPromise;
  deleteRedirect: (where: RedirectWhereUniqueInput) => RedirectPromise;
  deleteManyRedirects: (where?: RedirectWhereInput) => BatchPayloadPromise;
  createXeroUser: (data: XeroUserCreateInput) => XeroUserPromise;
  updateXeroUser: (args: {
    data: XeroUserUpdateInput;
    where: XeroUserWhereUniqueInput;
  }) => XeroUserPromise;
  updateManyXeroUsers: (args: {
    data: XeroUserUpdateManyMutationInput;
    where?: XeroUserWhereInput;
  }) => BatchPayloadPromise;
  upsertXeroUser: (args: {
    where: XeroUserWhereUniqueInput;
    create: XeroUserCreateInput;
    update: XeroUserUpdateInput;
  }) => XeroUserPromise;
  deleteXeroUser: (where: XeroUserWhereUniqueInput) => XeroUserPromise;
  deleteManyXeroUsers: (where?: XeroUserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  auth: (
    where?: AuthSubscriptionWhereInput
  ) => AuthSubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  redirect: (
    where?: RedirectSubscriptionWhereInput
  ) => RedirectSubscriptionPayloadSubscription;
  xeroUser: (
    where?: XeroUserSubscriptionWhereInput
  ) => XeroUserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "xeroId_ASC"
  | "xeroId_DESC";

export type AuthOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "apiUrl_ASC"
  | "apiUrl_DESC";

export type RedirectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "redirectUrl_ASC"
  | "redirectUrl_DESC";

export type XeroUserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "accessToken_ASC"
  | "accessToken_DESC"
  | "refreshToken_ASC"
  | "refreshToken_DESC"
  | "tenantId_ASC"
  | "tenantId_DESC";

export interface RedirectUpdateInput {
  redirectUrl?: Maybe<String>;
}

export type AuthWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RedirectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AuthSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AuthWhereInput>;
  AND?: Maybe<AuthSubscriptionWhereInput[] | AuthSubscriptionWhereInput>;
  OR?: Maybe<AuthSubscriptionWhereInput[] | AuthSubscriptionWhereInput>;
  NOT?: Maybe<AuthSubscriptionWhereInput[] | AuthSubscriptionWhereInput>;
}

export interface ContactUpdateInput {
  code?: Maybe<String>;
  xeroId?: Maybe<String>;
}

export interface XeroUserUpdateInput {
  accessToken?: Maybe<String>;
  refreshToken?: Maybe<String>;
  tenantId?: Maybe<String>;
}

export interface RedirectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  redirectUrl?: Maybe<String>;
  redirectUrl_not?: Maybe<String>;
  redirectUrl_in?: Maybe<String[] | String>;
  redirectUrl_not_in?: Maybe<String[] | String>;
  redirectUrl_lt?: Maybe<String>;
  redirectUrl_lte?: Maybe<String>;
  redirectUrl_gt?: Maybe<String>;
  redirectUrl_gte?: Maybe<String>;
  redirectUrl_contains?: Maybe<String>;
  redirectUrl_not_contains?: Maybe<String>;
  redirectUrl_starts_with?: Maybe<String>;
  redirectUrl_not_starts_with?: Maybe<String>;
  redirectUrl_ends_with?: Maybe<String>;
  redirectUrl_not_ends_with?: Maybe<String>;
  AND?: Maybe<RedirectWhereInput[] | RedirectWhereInput>;
  OR?: Maybe<RedirectWhereInput[] | RedirectWhereInput>;
  NOT?: Maybe<RedirectWhereInput[] | RedirectWhereInput>;
}

export type ContactWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
  xeroId?: Maybe<String>;
}>;

export interface AuthWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  apiUrl?: Maybe<String>;
  apiUrl_not?: Maybe<String>;
  apiUrl_in?: Maybe<String[] | String>;
  apiUrl_not_in?: Maybe<String[] | String>;
  apiUrl_lt?: Maybe<String>;
  apiUrl_lte?: Maybe<String>;
  apiUrl_gt?: Maybe<String>;
  apiUrl_gte?: Maybe<String>;
  apiUrl_contains?: Maybe<String>;
  apiUrl_not_contains?: Maybe<String>;
  apiUrl_starts_with?: Maybe<String>;
  apiUrl_not_starts_with?: Maybe<String>;
  apiUrl_ends_with?: Maybe<String>;
  apiUrl_not_ends_with?: Maybe<String>;
  AND?: Maybe<AuthWhereInput[] | AuthWhereInput>;
  OR?: Maybe<AuthWhereInput[] | AuthWhereInput>;
  NOT?: Maybe<AuthWhereInput[] | AuthWhereInput>;
}

export interface ContactWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  xeroId?: Maybe<String>;
  xeroId_not?: Maybe<String>;
  xeroId_in?: Maybe<String[] | String>;
  xeroId_not_in?: Maybe<String[] | String>;
  xeroId_lt?: Maybe<String>;
  xeroId_lte?: Maybe<String>;
  xeroId_gt?: Maybe<String>;
  xeroId_gte?: Maybe<String>;
  xeroId_contains?: Maybe<String>;
  xeroId_not_contains?: Maybe<String>;
  xeroId_starts_with?: Maybe<String>;
  xeroId_not_starts_with?: Maybe<String>;
  xeroId_ends_with?: Maybe<String>;
  xeroId_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  OR?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  NOT?: Maybe<ContactWhereInput[] | ContactWhereInput>;
}

export interface ContactCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  xeroId: String;
}

export interface XeroUserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<XeroUserWhereInput>;
  AND?: Maybe<
    XeroUserSubscriptionWhereInput[] | XeroUserSubscriptionWhereInput
  >;
  OR?: Maybe<XeroUserSubscriptionWhereInput[] | XeroUserSubscriptionWhereInput>;
  NOT?: Maybe<
    XeroUserSubscriptionWhereInput[] | XeroUserSubscriptionWhereInput
  >;
}

export interface AuthUpdateManyMutationInput {
  apiUrl?: Maybe<String>;
}

export interface ContactUpdateManyMutationInput {
  code?: Maybe<String>;
  xeroId?: Maybe<String>;
}

export interface AuthUpdateInput {
  apiUrl?: Maybe<String>;
}

export interface XeroUserCreateInput {
  id?: Maybe<ID_Input>;
  accessToken: String;
  refreshToken: String;
  tenantId: String;
}

export interface RedirectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RedirectWhereInput>;
  AND?: Maybe<
    RedirectSubscriptionWhereInput[] | RedirectSubscriptionWhereInput
  >;
  OR?: Maybe<RedirectSubscriptionWhereInput[] | RedirectSubscriptionWhereInput>;
  NOT?: Maybe<
    RedirectSubscriptionWhereInput[] | RedirectSubscriptionWhereInput
  >;
}

export interface XeroUserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  accessToken?: Maybe<String>;
  accessToken_not?: Maybe<String>;
  accessToken_in?: Maybe<String[] | String>;
  accessToken_not_in?: Maybe<String[] | String>;
  accessToken_lt?: Maybe<String>;
  accessToken_lte?: Maybe<String>;
  accessToken_gt?: Maybe<String>;
  accessToken_gte?: Maybe<String>;
  accessToken_contains?: Maybe<String>;
  accessToken_not_contains?: Maybe<String>;
  accessToken_starts_with?: Maybe<String>;
  accessToken_not_starts_with?: Maybe<String>;
  accessToken_ends_with?: Maybe<String>;
  accessToken_not_ends_with?: Maybe<String>;
  refreshToken?: Maybe<String>;
  refreshToken_not?: Maybe<String>;
  refreshToken_in?: Maybe<String[] | String>;
  refreshToken_not_in?: Maybe<String[] | String>;
  refreshToken_lt?: Maybe<String>;
  refreshToken_lte?: Maybe<String>;
  refreshToken_gt?: Maybe<String>;
  refreshToken_gte?: Maybe<String>;
  refreshToken_contains?: Maybe<String>;
  refreshToken_not_contains?: Maybe<String>;
  refreshToken_starts_with?: Maybe<String>;
  refreshToken_not_starts_with?: Maybe<String>;
  refreshToken_ends_with?: Maybe<String>;
  refreshToken_not_ends_with?: Maybe<String>;
  tenantId?: Maybe<String>;
  tenantId_not?: Maybe<String>;
  tenantId_in?: Maybe<String[] | String>;
  tenantId_not_in?: Maybe<String[] | String>;
  tenantId_lt?: Maybe<String>;
  tenantId_lte?: Maybe<String>;
  tenantId_gt?: Maybe<String>;
  tenantId_gte?: Maybe<String>;
  tenantId_contains?: Maybe<String>;
  tenantId_not_contains?: Maybe<String>;
  tenantId_starts_with?: Maybe<String>;
  tenantId_not_starts_with?: Maybe<String>;
  tenantId_ends_with?: Maybe<String>;
  tenantId_not_ends_with?: Maybe<String>;
  AND?: Maybe<XeroUserWhereInput[] | XeroUserWhereInput>;
  OR?: Maybe<XeroUserWhereInput[] | XeroUserWhereInput>;
  NOT?: Maybe<XeroUserWhereInput[] | XeroUserWhereInput>;
}

export interface AuthCreateInput {
  id?: Maybe<ID_Input>;
  apiUrl?: Maybe<String>;
}

export type XeroUserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RedirectUpdateManyMutationInput {
  redirectUrl?: Maybe<String>;
}

export interface XeroUserUpdateManyMutationInput {
  accessToken?: Maybe<String>;
  refreshToken?: Maybe<String>;
  tenantId?: Maybe<String>;
}

export interface RedirectCreateInput {
  id?: Maybe<ID_Input>;
  redirectUrl?: Maybe<String>;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactWhereInput>;
  AND?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  OR?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  NOT?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface XeroUserConnection {
  pageInfo: PageInfo;
  edges: XeroUserEdge[];
}

export interface XeroUserConnectionPromise
  extends Promise<XeroUserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<XeroUserEdge>>() => T;
  aggregate: <T = AggregateXeroUserPromise>() => T;
}

export interface XeroUserConnectionSubscription
  extends Promise<AsyncIterator<XeroUserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<XeroUserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateXeroUserSubscription>() => T;
}

export interface AuthEdge {
  node: Auth;
  cursor: String;
}

export interface AuthEdgePromise extends Promise<AuthEdge>, Fragmentable {
  node: <T = AuthPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuthEdgeSubscription
  extends Promise<AsyncIterator<AuthEdge>>,
    Fragmentable {
  node: <T = AuthSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface XeroUserPreviousValues {
  id: ID_Output;
  accessToken: String;
  refreshToken: String;
  tenantId: String;
}

export interface XeroUserPreviousValuesPromise
  extends Promise<XeroUserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  accessToken: () => Promise<String>;
  refreshToken: () => Promise<String>;
  tenantId: () => Promise<String>;
}

export interface XeroUserPreviousValuesSubscription
  extends Promise<AsyncIterator<XeroUserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
  tenantId: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAuth {
  count: Int;
}

export interface AggregateAuthPromise
  extends Promise<AggregateAuth>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuthSubscription
  extends Promise<AsyncIterator<AggregateAuth>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RedirectSubscriptionPayload {
  mutation: MutationType;
  node: Redirect;
  updatedFields: String[];
  previousValues: RedirectPreviousValues;
}

export interface RedirectSubscriptionPayloadPromise
  extends Promise<RedirectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RedirectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RedirectPreviousValuesPromise>() => T;
}

export interface RedirectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RedirectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RedirectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RedirectPreviousValuesSubscription>() => T;
}

export interface AggregateXeroUser {
  count: Int;
}

export interface AggregateXeroUserPromise
  extends Promise<AggregateXeroUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateXeroUserSubscription
  extends Promise<AsyncIterator<AggregateXeroUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface XeroUserEdge {
  node: XeroUser;
  cursor: String;
}

export interface XeroUserEdgePromise
  extends Promise<XeroUserEdge>,
    Fragmentable {
  node: <T = XeroUserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface XeroUserEdgeSubscription
  extends Promise<AsyncIterator<XeroUserEdge>>,
    Fragmentable {
  node: <T = XeroUserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface XeroUser {
  id: ID_Output;
  accessToken: String;
  refreshToken: String;
  tenantId: String;
}

export interface XeroUserPromise extends Promise<XeroUser>, Fragmentable {
  id: () => Promise<ID_Output>;
  accessToken: () => Promise<String>;
  refreshToken: () => Promise<String>;
  tenantId: () => Promise<String>;
}

export interface XeroUserSubscription
  extends Promise<AsyncIterator<XeroUser>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
  tenantId: () => Promise<AsyncIterator<String>>;
}

export interface XeroUserNullablePromise
  extends Promise<XeroUser | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  accessToken: () => Promise<String>;
  refreshToken: () => Promise<String>;
  tenantId: () => Promise<String>;
}

export interface RedirectEdge {
  node: Redirect;
  cursor: String;
}

export interface RedirectEdgePromise
  extends Promise<RedirectEdge>,
    Fragmentable {
  node: <T = RedirectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RedirectEdgeSubscription
  extends Promise<AsyncIterator<RedirectEdge>>,
    Fragmentable {
  node: <T = RedirectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface XeroUserSubscriptionPayload {
  mutation: MutationType;
  node: XeroUser;
  updatedFields: String[];
  previousValues: XeroUserPreviousValues;
}

export interface XeroUserSubscriptionPayloadPromise
  extends Promise<XeroUserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = XeroUserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = XeroUserPreviousValuesPromise>() => T;
}

export interface XeroUserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<XeroUserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = XeroUserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = XeroUserPreviousValuesSubscription>() => T;
}

export interface AuthConnection {
  pageInfo: PageInfo;
  edges: AuthEdge[];
}

export interface AuthConnectionPromise
  extends Promise<AuthConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuthEdge>>() => T;
  aggregate: <T = AggregateAuthPromise>() => T;
}

export interface AuthConnectionSubscription
  extends Promise<AsyncIterator<AuthConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuthEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuthSubscription>() => T;
}

export interface Redirect {
  id: ID_Output;
  redirectUrl?: String;
}

export interface RedirectPromise extends Promise<Redirect>, Fragmentable {
  id: () => Promise<ID_Output>;
  redirectUrl: () => Promise<String>;
}

export interface RedirectSubscription
  extends Promise<AsyncIterator<Redirect>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  redirectUrl: () => Promise<AsyncIterator<String>>;
}

export interface RedirectNullablePromise
  extends Promise<Redirect | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  redirectUrl: () => Promise<String>;
}

export interface AuthSubscriptionPayload {
  mutation: MutationType;
  node: Auth;
  updatedFields: String[];
  previousValues: AuthPreviousValues;
}

export interface AuthSubscriptionPayloadPromise
  extends Promise<AuthSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuthPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuthPreviousValuesPromise>() => T;
}

export interface AuthSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuthSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuthSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuthPreviousValuesSubscription>() => T;
}

export interface ContactEdge {
  node: Contact;
  cursor: String;
}

export interface ContactEdgePromise extends Promise<ContactEdge>, Fragmentable {
  node: <T = ContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdge>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AuthPreviousValues {
  id: ID_Output;
  apiUrl?: String;
}

export interface AuthPreviousValuesPromise
  extends Promise<AuthPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  apiUrl: () => Promise<String>;
}

export interface AuthPreviousValuesSubscription
  extends Promise<AsyncIterator<AuthPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  apiUrl: () => Promise<AsyncIterator<String>>;
}

export interface Contact {
  id: ID_Output;
  code: String;
  xeroId: String;
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  xeroId: () => Promise<String>;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  xeroId: () => Promise<AsyncIterator<String>>;
}

export interface ContactNullablePromise
  extends Promise<Contact | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  xeroId: () => Promise<String>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface RedirectPreviousValues {
  id: ID_Output;
  redirectUrl?: String;
}

export interface RedirectPreviousValuesPromise
  extends Promise<RedirectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  redirectUrl: () => Promise<String>;
}

export interface RedirectPreviousValuesSubscription
  extends Promise<AsyncIterator<RedirectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  redirectUrl: () => Promise<AsyncIterator<String>>;
}

export interface ContactPreviousValues {
  id: ID_Output;
  code: String;
  xeroId: String;
}

export interface ContactPreviousValuesPromise
  extends Promise<ContactPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  xeroId: () => Promise<String>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  xeroId: () => Promise<AsyncIterator<String>>;
}

export interface ContactSubscriptionPayload {
  mutation: MutationType;
  node: Contact;
  updatedFields: String[];
  previousValues: ContactPreviousValues;
}

export interface ContactSubscriptionPayloadPromise
  extends Promise<ContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValuesPromise>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface Auth {
  id: ID_Output;
  apiUrl?: String;
}

export interface AuthPromise extends Promise<Auth>, Fragmentable {
  id: () => Promise<ID_Output>;
  apiUrl: () => Promise<String>;
}

export interface AuthSubscription
  extends Promise<AsyncIterator<Auth>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  apiUrl: () => Promise<AsyncIterator<String>>;
}

export interface AuthNullablePromise
  extends Promise<Auth | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  apiUrl: () => Promise<String>;
}

export interface RedirectConnection {
  pageInfo: PageInfo;
  edges: RedirectEdge[];
}

export interface RedirectConnectionPromise
  extends Promise<RedirectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RedirectEdge>>() => T;
  aggregate: <T = AggregateRedirectPromise>() => T;
}

export interface RedirectConnectionSubscription
  extends Promise<AsyncIterator<RedirectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RedirectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRedirectSubscription>() => T;
}

export interface AggregateRedirect {
  count: Int;
}

export interface AggregateRedirectPromise
  extends Promise<AggregateRedirect>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRedirectSubscription
  extends Promise<AsyncIterator<AggregateRedirect>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactConnection {
  pageInfo: PageInfo;
  edges: ContactEdge[];
}

export interface ContactConnectionPromise
  extends Promise<ContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactEdge>>() => T;
  aggregate: <T = AggregateContactPromise>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface AggregateContact {
  count: Int;
}

export interface AggregateContactPromise
  extends Promise<AggregateContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Auth",
    embedded: false
  },
  {
    name: "Redirect",
    embedded: false
  },
  {
    name: "XeroUser",
    embedded: false
  },
  {
    name: "Contact",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
